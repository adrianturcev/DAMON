{
  "version": 3,
  "sources": ["node_modules/tslib/tslib.es6.mjs", "node_modules/clarinet/clarinet.js", "node_modules/json-in-order/src/index.ts", "Damon.js", "main.js"],
  "sourcesContent": ["/******************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\n/* global Reflect, Promise, SuppressedError, Symbol, Iterator */\n\nvar extendStatics = function(d, b) {\n  extendStatics = Object.setPrototypeOf ||\n      ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n      function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n  return extendStatics(d, b);\n};\n\nexport function __extends(d, b) {\n  if (typeof b !== \"function\" && b !== null)\n      throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n  extendStatics(d, b);\n  function __() { this.constructor = d; }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nexport var __assign = function() {\n  __assign = Object.assign || function __assign(t) {\n      for (var s, i = 1, n = arguments.length; i < n; i++) {\n          s = arguments[i];\n          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n      return t;\n  }\n  return __assign.apply(this, arguments);\n}\n\nexport function __rest(s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n      t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n              t[p[i]] = s[p[i]];\n      }\n  return t;\n}\n\nexport function __decorate(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\n\nexport function __param(paramIndex, decorator) {\n  return function (target, key) { decorator(target, key, paramIndex); }\n}\n\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n  function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\n  var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n  var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n  var _, done = false;\n  for (var i = decorators.length - 1; i >= 0; i--) {\n      var context = {};\n      for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\n      for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n      context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\n      var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\n      if (kind === \"accessor\") {\n          if (result === void 0) continue;\n          if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n          if (_ = accept(result.get)) descriptor.get = _;\n          if (_ = accept(result.set)) descriptor.set = _;\n          if (_ = accept(result.init)) initializers.unshift(_);\n      }\n      else if (_ = accept(result)) {\n          if (kind === \"field\") initializers.unshift(_);\n          else descriptor[key] = _;\n      }\n  }\n  if (target) Object.defineProperty(target, contextIn.name, descriptor);\n  done = true;\n};\n\nexport function __runInitializers(thisArg, initializers, value) {\n  var useValue = arguments.length > 2;\n  for (var i = 0; i < initializers.length; i++) {\n      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n  }\n  return useValue ? value : void 0;\n};\n\nexport function __propKey(x) {\n  return typeof x === \"symbol\" ? x : \"\".concat(x);\n};\n\nexport function __setFunctionName(f, name, prefix) {\n  if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\n  return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\n};\n\nexport function __metadata(metadataKey, metadataValue) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\n}\n\nexport function __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n  return new (P || (P = Promise))(function (resolve, reject) {\n      function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n      function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n      function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\n\nexport function __generator(thisArg, body) {\n  var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === \"function\" ? Iterator : Object).prototype);\n  return g.next = verb(0), g[\"throw\"] = verb(1), g[\"return\"] = verb(2), typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n  function verb(n) { return function (v) { return step([n, v]); }; }\n  function step(op) {\n      if (f) throw new TypeError(\"Generator is already executing.\");\n      while (g && (g = 0, op[0] && (_ = 0)), _) try {\n          if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n          if (y = 0, t) op = [op[0] & 2, t.value];\n          switch (op[0]) {\n              case 0: case 1: t = op; break;\n              case 4: _.label++; return { value: op[1], done: false };\n              case 5: _.label++; y = op[1]; op = [0]; continue;\n              case 7: op = _.ops.pop(); _.trys.pop(); continue;\n              default:\n                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                  if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                  if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                  if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                  if (t[2]) _.ops.pop();\n                  _.trys.pop(); continue;\n          }\n          op = body.call(thisArg, _);\n      } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n      if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n  }\n}\n\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n  }\n  Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nexport function __exportStar(m, o) {\n  for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\n}\n\nexport function __values(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n      next: function () {\n          if (o && i >= o.length) o = void 0;\n          return { value: o && o[i++], done: !o };\n      }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\n\nexport function __read(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o), r, ar = [], e;\n  try {\n      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  }\n  catch (error) { e = { error: error }; }\n  finally {\n      try {\n          if (r && !r.done && (m = i[\"return\"])) m.call(i);\n      }\n      finally { if (e) throw e.error; }\n  }\n  return ar;\n}\n\n/** @deprecated */\nexport function __spread() {\n  for (var ar = [], i = 0; i < arguments.length; i++)\n      ar = ar.concat(__read(arguments[i]));\n  return ar;\n}\n\n/** @deprecated */\nexport function __spreadArrays() {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n  for (var r = Array(s), k = 0, i = 0; i < il; i++)\n      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n          r[k] = a[j];\n  return r;\n}\n\nexport function __spreadArray(to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n      if (ar || !(i in from)) {\n          if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n          ar[i] = from[i];\n      }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n}\n\nexport function __await(v) {\n  return this instanceof __await ? (this.v = v, this) : new __await(v);\n}\n\nexport function __asyncGenerator(thisArg, _arguments, generator) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var g = generator.apply(thisArg, _arguments || []), i, q = [];\n  return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\n  function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\n  function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\n  function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n  function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n  function fulfill(value) { resume(\"next\", value); }\n  function reject(value) { resume(\"throw\", value); }\n  function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n}\n\nexport function __asyncDelegator(o) {\n  var i, p;\n  return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\n  function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\n}\n\nexport function __asyncValues(o) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m = o[Symbol.asyncIterator], i;\n  return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n  function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n  function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n}\n\nexport function __makeTemplateObject(cooked, raw) {\n  if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\n  return cooked;\n};\n\nvar __setModuleDefault = Object.create ? (function(o, v) {\n  Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n  o[\"default\"] = v;\n};\n\nvar ownKeys = function(o) {\n  ownKeys = Object.getOwnPropertyNames || function (o) {\n    var ar = [];\n    for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n    return ar;\n  };\n  return ownKeys(o);\n};\n\nexport function __importStar(mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n  __setModuleDefault(result, mod);\n  return result;\n}\n\nexport function __importDefault(mod) {\n  return (mod && mod.__esModule) ? mod : { default: mod };\n}\n\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n}\n\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n}\n\nexport function __classPrivateFieldIn(state, receiver) {\n  if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\n  return typeof state === \"function\" ? receiver === state : state.has(receiver);\n}\n\nexport function __addDisposableResource(env, value, async) {\n  if (value !== null && value !== void 0) {\n    if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\n    var dispose, inner;\n    if (async) {\n      if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\n      dispose = value[Symbol.asyncDispose];\n    }\n    if (dispose === void 0) {\n      if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\n      dispose = value[Symbol.dispose];\n      if (async) inner = dispose;\n    }\n    if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\n    if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };\n    env.stack.push({ value: value, dispose: dispose, async: async });\n  }\n  else if (async) {\n    env.stack.push({ async: true });\n  }\n  return value;\n}\n\nvar _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n  var e = new Error(message);\n  return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\n\nexport function __disposeResources(env) {\n  function fail(e) {\n    env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\n    env.hasError = true;\n  }\n  var r, s = 0;\n  function next() {\n    while (r = env.stack.pop()) {\n      try {\n        if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);\n        if (r.dispose) {\n          var result = r.dispose.call(r.value);\n          if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });\n        }\n        else s |= 1;\n      }\n      catch (e) {\n        fail(e);\n      }\n    }\n    if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();\n    if (env.hasError) throw env.error;\n  }\n  return next();\n}\n\nexport function __rewriteRelativeImportExtension(path, preserveJsx) {\n  if (typeof path === \"string\" && /^\\.\\.?\\//.test(path)) {\n      return path.replace(/\\.(tsx)$|((?:\\.d)?)((?:\\.[^./]+?)?)\\.([cm]?)ts$/i, function (m, tsx, d, ext, cm) {\n          return tsx ? preserveJsx ? \".jsx\" : \".js\" : d && (!ext || !cm) ? m : (d + ext + \".\" + cm.toLowerCase() + \"js\");\n      });\n  }\n  return path;\n}\n\nexport default {\n  __extends,\n  __assign,\n  __rest,\n  __decorate,\n  __param,\n  __esDecorate,\n  __runInitializers,\n  __propKey,\n  __setFunctionName,\n  __metadata,\n  __awaiter,\n  __generator,\n  __createBinding,\n  __exportStar,\n  __values,\n  __read,\n  __spread,\n  __spreadArrays,\n  __spreadArray,\n  __await,\n  __asyncGenerator,\n  __asyncDelegator,\n  __asyncValues,\n  __makeTemplateObject,\n  __importStar,\n  __importDefault,\n  __classPrivateFieldGet,\n  __classPrivateFieldSet,\n  __classPrivateFieldIn,\n  __addDisposableResource,\n  __disposeResources,\n  __rewriteRelativeImportExtension,\n};\n", ";(function (clarinet) {\n  \"use strict\";\n\n  // non node-js needs to set clarinet debug on root\n  var env =(typeof process === 'object' && process.env)\n    ? process.env\n    : self;\n\n  clarinet.parser            = function (opt) { return new CParser(opt);};\n  clarinet.CParser           = CParser;\n  clarinet.CStream           = CStream;\n  clarinet.createStream      = createStream;\n  clarinet.MAX_BUFFER_LENGTH = 64 * 1024;\n  clarinet.DEBUG             = (env.CDEBUG==='debug');\n  clarinet.INFO              = (env.CDEBUG==='debug' || env.CDEBUG==='info');\n  clarinet.EVENTS            =\n    [ \"value\"\n    , \"string\"\n    , \"key\"\n    , \"openobject\"\n    , \"closeobject\"\n    , \"openarray\"\n    , \"closearray\"\n    , \"error\"\n    , \"end\"\n    , \"ready\"\n    ];\n\n  var buffers     = {\n        textNode: undefined,\n        numberNode: \"\"\n    }\n    , streamWraps = clarinet.EVENTS.filter(function (ev) {\n          return ev !== \"error\" && ev !== \"end\";\n        })\n    , S           = 0\n    , Stream\n    ;\n\n  clarinet.STATE =\n    { BEGIN                             : S++\n    , VALUE                             : S++ // general stuff\n    , OPEN_OBJECT                       : S++ // {\n    , CLOSE_OBJECT                      : S++ // }\n    , OPEN_ARRAY                        : S++ // [\n    , CLOSE_ARRAY                       : S++ // ]\n    , TEXT_ESCAPE                       : S++ // \\ stuff\n    , STRING                            : S++ // \"\"\n    , BACKSLASH                         : S++\n    , END                               : S++ // No more stack\n    , OPEN_KEY                          : S++ // , \"a\"\n    , CLOSE_KEY                         : S++ // :\n    , TRUE                              : S++ // r\n    , TRUE2                             : S++ // u\n    , TRUE3                             : S++ // e\n    , FALSE                             : S++ // a\n    , FALSE2                            : S++ // l\n    , FALSE3                            : S++ // s\n    , FALSE4                            : S++ // e\n    , NULL                              : S++ // u\n    , NULL2                             : S++ // l\n    , NULL3                             : S++ // l\n    , NUMBER_DECIMAL_POINT              : S++ // .\n    , NUMBER_DIGIT                      : S++ // [0-9]\n    };\n\n  for (var s_ in clarinet.STATE) clarinet.STATE[clarinet.STATE[s_]] = s_;\n\n  // switcharoo\n  S = clarinet.STATE;\n\n  const Char = {\n    tab                 : 0x09,     // \\t\n    lineFeed            : 0x0A,     // \\n\n    carriageReturn      : 0x0D,     // \\r\n    space               : 0x20,     // \" \"\n\n    doubleQuote         : 0x22,     // \"\n    plus                : 0x2B,     // +\n    comma               : 0x2C,     // ,\n    minus               : 0x2D,     // -\n    period              : 0x2E,     // .\n\n    _0                  : 0x30,     // 0\n    _9                  : 0x39,     // 9\n\n    colon               : 0x3A,     // :\n\n    E                   : 0x45,     // E\n\n    openBracket         : 0x5B,     // [\n    backslash           : 0x5C,     // \\\n    closeBracket        : 0x5D,     // ]\n\n    a                   : 0x61,     // a\n    b                   : 0x62,     // b\n    e                   : 0x65,     // e \n    f                   : 0x66,     // f\n    l                   : 0x6C,     // l\n    n                   : 0x6E,     // n\n    r                   : 0x72,     // r\n    s                   : 0x73,     // s\n    t                   : 0x74,     // t\n    u                   : 0x75,     // u\n\n    openBrace           : 0x7B,     // {\n    closeBrace          : 0x7D,     // }\n  }\n\n  if (!Object.create) {\n    Object.create = function (o) {\n      function f () { this[\"__proto__\"] = o; }\n      f.prototype = o;\n      return new f;\n    };\n  }\n\n  if (!Object.getPrototypeOf) {\n    Object.getPrototypeOf = function (o) {\n      return o[\"__proto__\"];\n    };\n  }\n\n  if (!Object.keys) {\n    Object.keys = function (o) {\n      var a = [];\n      for (var i in o) if (o.hasOwnProperty(i)) a.push(i);\n      return a;\n    };\n  }\n\n  function checkBufferLength (parser) {\n    var maxAllowed = Math.max(clarinet.MAX_BUFFER_LENGTH, 10)\n      , maxActual = 0\n      ;\n    for (var buffer in buffers) {\n      var len = parser[buffer] === undefined ? 0 : parser[buffer].length;\n      if (len > maxAllowed) {\n        switch (buffer) {\n          case \"text\":\n            closeText(parser);\n          break;\n\n          default:\n            error(parser, \"Max buffer length exceeded: \"+ buffer);\n        }\n      }\n      maxActual = Math.max(maxActual, len);\n    }\n    parser.bufferCheckPosition = (clarinet.MAX_BUFFER_LENGTH - maxActual)\n                               + parser.position;\n  }\n\n  function clearBuffers (parser) {\n    for (var buffer in buffers) {\n      parser[buffer] = buffers[buffer];\n    }\n  }\n\n  var stringTokenPattern = /[\\\\\"\\n]/g;\n\n  function CParser (opt) {\n    if (!(this instanceof CParser)) return new CParser (opt);\n\n    var parser = this;\n    clearBuffers(parser);\n    parser.bufferCheckPosition = clarinet.MAX_BUFFER_LENGTH;\n    parser.q        = parser.c = parser.p = \"\";\n    parser.opt      = opt || {};\n    parser.closed   = parser.closedRoot = parser.sawRoot = false;\n    parser.tag      = parser.error = null;\n    parser.state    = S.BEGIN;\n    parser.stack    = new Array();\n    // mostly just for error reporting\n    parser.position = parser.column = 0;\n    parser.line     = 1;\n    parser.slashed  = false;\n    parser.unicodeI = 0;\n    parser.unicodeS = null;\n    parser.depth    = 0;\n    emit(parser, \"onready\");\n  }\n\n  CParser.prototype =\n    { end    : function () { end(this); }\n    , write  : write\n    , resume : function () { this.error = null; return this; }\n    , close  : function () { return this.write(null); }\n    };\n\n  try        { Stream = require(\"stream\").Stream; }\n  catch (ex) { Stream = function () {}; }\n\n  function createStream (opt) { return new CStream(opt); }\n\n  function CStream (opt) {\n    if (!(this instanceof CStream)) return new CStream(opt);\n\n    this._parser = new CParser(opt);\n    this.writable = true;\n    this.readable = true;\n\n    //var Buffer = this.Buffer || function Buffer () {}; // if we don't have Buffers, fake it so we can do `var instanceof Buffer` and not throw an error\n    this.bytes_remaining = 0; // number of bytes remaining in multi byte utf8 char to read after split boundary\n    this.bytes_in_sequence = 0; // bytes in multi byte utf8 char to read\n    this.temp_buffs = { \"2\": new Buffer(2), \"3\": new Buffer(3), \"4\": new Buffer(4) }; // for rebuilding chars split before boundary is reached\n    this.string = '';\n\n    var me = this;\n    Stream.apply(me);\n\n    this._parser.onend = function () { me.emit(\"end\"); };\n    this._parser.onerror = function (er) {\n      me.emit(\"error\", er);\n      me._parser.error = null;\n    };\n\n    streamWraps.forEach(function (ev) {\n      Object.defineProperty(me, \"on\" + ev,\n        { get          : function () { return me._parser[\"on\" + ev]; }\n        , set          : function (h) {\n            if (!h) {\n              me.removeAllListeners(ev);\n              me._parser[\"on\"+ev] = h;\n              return h;\n            }\n            me.on(ev, h);\n          }\n        , enumerable   : true\n        , configurable : false\n        });\n    });\n  }\n\n  CStream.prototype = Object.create(Stream.prototype,\n    { constructor: { value: CStream } });\n\n  CStream.prototype.write = function (data) {\n    data = new Buffer(data);\n    for (var i = 0; i < data.length; i++) {\n      var n = data[i];\n\n      // check for carry over of a multi byte char split between data chunks\n      // & fill temp buffer it with start of this data chunk up to the boundary limit set in the last iteration\n      if (this.bytes_remaining > 0) {\n        for (var j = 0; j < this.bytes_remaining; j++) {\n          this.temp_buffs[this.bytes_in_sequence][this.bytes_in_sequence - this.bytes_remaining + j] = data[j];\n        }\n        this.string = this.temp_buffs[this.bytes_in_sequence].toString();\n        this.bytes_in_sequence = this.bytes_remaining = 0;\n\n        // move iterator forward by number of byte read during sequencing\n        i = i + j - 1;\n\n        // pass data to parser and move forward to parse rest of data\n        this._parser.write(this.string);\n        this.emit(\"data\", this.string);\n        continue;\n      }\n\n      // if no remainder bytes carried over, parse multi byte (>=128) chars one at a time\n      if (this.bytes_remaining === 0 && n >= 128) {\n        if ((n >= 194) && (n <= 223)) this.bytes_in_sequence = 2;\n        if ((n >= 224) && (n <= 239)) this.bytes_in_sequence = 3;\n        if ((n >= 240) && (n <= 244)) this.bytes_in_sequence = 4;\n        if ((this.bytes_in_sequence + i) > data.length) { // if bytes needed to complete char fall outside data length, we have a boundary split\n\n          for (var k = 0; k <= (data.length - 1 - i); k++) {\n            this.temp_buffs[this.bytes_in_sequence][k] = data[i + k]; // fill temp data of correct size with bytes available in this chunk\n          }\n          this.bytes_remaining = (i + this.bytes_in_sequence) - data.length;\n\n          // immediately return as we need another chunk to sequence the character\n          return true;\n        } else {\n          this.string = data.slice(i, (i + this.bytes_in_sequence)).toString();\n          i = i + this.bytes_in_sequence - 1;\n\n          this._parser.write(this.string);\n          this.emit(\"data\", this.string);\n          continue;\n        }\n      }\n\n      // is there a range of characters that are immediately parsable?\n      for (var p = i; p < data.length; p++) {\n        if (data[p] >= 128) break;\n      }\n      this.string = data.slice(i, p).toString();\n      this._parser.write(this.string);\n      this.emit(\"data\", this.string);\n      i = p - 1;\n\n      // handle any remaining characters using multibyte logic\n      continue;\n    }\n  };\n\n  CStream.prototype.end = function (chunk) {\n    if (chunk && chunk.length) this._parser.write(chunk.toString());\n    this._parser.end();\n    return true;\n  };\n\n  CStream.prototype.on = function (ev, handler) {\n    var me = this;\n    if (!me._parser[\"on\"+ev] && streamWraps.indexOf(ev) !== -1) {\n      me._parser[\"on\"+ev] = function () {\n        var args = arguments.length === 1 ? [arguments[0]]\n                 : Array.apply(null, arguments);\n        args.splice(0, 0, ev);\n        me.emit.apply(me, args);\n      };\n    }\n    return Stream.prototype.on.call(me, ev, handler);\n  };\n\n  CStream.prototype.destroy = function () {\n    clearBuffers(this._parser);\n    this.emit(\"close\");\n  };\n\n  function emit(parser, event, data) {\n    if(clarinet.INFO) console.log('-- emit', event, data);\n    if (parser[event]) parser[event](data);\n  }\n\n  function emitNode(parser, event, data) {\n    closeValue(parser);\n    emit(parser, event, data);\n  }\n\n  function closeValue(parser, event) {\n    parser.textNode = textopts(parser.opt, parser.textNode);\n    if (parser.textNode !== undefined) {\n      emit(parser, (event ? event : \"onvalue\"), parser.textNode);\n    }\n    parser.textNode = undefined;\n  }\n\n  function closeNumber(parser) {\n    if (parser.numberNode)\n      emit(parser, \"onvalue\", parseFloat(parser.numberNode));\n    parser.numberNode = \"\";\n  }\n\n  function textopts (opt, text) {\n    if (text === undefined) {\n      return text;\n    }\n    if (opt.trim) text = text.trim();\n    if (opt.normalize) text = text.replace(/\\s+/g, \" \");\n    return text;\n  }\n\n  function error (parser, er) {\n    closeValue(parser);\n    er += \"\\nLine: \"+parser.line+\n          \"\\nColumn: \"+parser.column+\n          \"\\nChar: \"+parser.c;\n    er = new Error(er);\n    parser.error = er;\n    emit(parser, \"onerror\", er);\n    return parser;\n  }\n\n  function end(parser) {\n    if (parser.state !== S.VALUE || parser.depth !== 0)\n      error(parser, \"Unexpected end\");\n\n    closeValue(parser);\n    parser.c      = \"\";\n    parser.closed = true;\n    emit(parser, \"onend\");\n    CParser.call(parser, parser.opt);\n    return parser;\n  }\n\n  function isWhitespace(c) {\n    return c === Char.carriageReturn || c === Char.lineFeed || c === Char.space || c === Char.tab;\n  }\n\n  function write (chunk) {\n    var parser = this;\n    if (this.error) throw this.error;\n    if (parser.closed) return error(parser,\n      \"Cannot write after close. Assign an onready handler.\");\n    if (chunk === null) return end(parser);\n    var i = 0, c = chunk.charCodeAt(0), p = parser.p;\n    var lockIncrements = false;\n    if (clarinet.DEBUG) console.log('write -> [' + chunk + ']');\n    while (c) {\n      p = c;\n      parser.c = c = chunk.charCodeAt(i++);\n      // if chunk doesnt have next, like streaming char by char\n      // this way we need to check if previous is really previous\n      // if not we need to reset to what the parser says is the previous\n      // from buffer\n      if(p !== c ) parser.p = p;\n      else p = parser.p;\n\n      if(!c) break;\n\n      if (clarinet.DEBUG) console.log(i,c,clarinet.STATE[parser.state]);\n      if (!lockIncrements) {\n        parser.position ++;\n        if (c === Char.lineFeed) {\n          parser.line ++;\n          parser.column = 0;\n        } else parser.column ++;\n      } else {\n        lockIncrements = false;\n      }\n      switch (parser.state) {\n\n        case S.BEGIN:\n          if (c === Char.openBrace) parser.state = S.OPEN_OBJECT;\n          else if (c === Char.openBracket) parser.state = S.OPEN_ARRAY;\n          else if (!isWhitespace(c))\n            error(parser, \"Non-whitespace before {[.\");\n        continue;\n\n        case S.OPEN_KEY:\n        case S.OPEN_OBJECT:\n          if (isWhitespace(c)) continue;\n          if(parser.state === S.OPEN_KEY) parser.stack.push(S.CLOSE_KEY);\n          else {\n            if(c === Char.closeBrace) {\n              emit(parser, 'onopenobject');\n              this.depth++;\n              emit(parser, 'oncloseobject');\n              this.depth--;\n              parser.state = parser.stack.pop() || S.VALUE;\n              continue;\n            } else  parser.stack.push(S.CLOSE_OBJECT);\n          }\n          if(c === Char.doubleQuote) parser.state = S.STRING;\n          else error(parser, \"Malformed object key should start with \\\"\");\n        continue;\n\n        case S.CLOSE_KEY:\n        case S.CLOSE_OBJECT:\n          if (isWhitespace(c)) continue;\n          var event = (parser.state === S.CLOSE_KEY) ? 'key' : 'object';\n          if(c === Char.colon) {\n            if(parser.state === S.CLOSE_OBJECT) {\n              parser.stack.push(S.CLOSE_OBJECT);\n              closeValue(parser, 'onopenobject');\n               this.depth++;\n            } else closeValue(parser, 'onkey');\n            parser.state  = S.VALUE;\n          } else if (c === Char.closeBrace) {\n            emitNode(parser, 'oncloseobject');\n            this.depth--;\n            parser.state = parser.stack.pop() || S.VALUE;\n          } else if(c === Char.comma) {\n            if(parser.state === S.CLOSE_OBJECT)\n              parser.stack.push(S.CLOSE_OBJECT);\n            closeValue(parser);\n            parser.state  = S.OPEN_KEY;\n          } else error(parser, 'Bad object');\n        continue;\n\n        case S.OPEN_ARRAY: // after an array there always a value\n        case S.VALUE:\n          if (isWhitespace(c)) continue;\n          if(parser.state===S.OPEN_ARRAY) {\n            emit(parser, 'onopenarray');\n            this.depth++;\n            parser.state = S.VALUE;\n            if(c === Char.closeBracket) {\n              emit(parser, 'onclosearray');\n              this.depth--;\n              parser.state = parser.stack.pop() || S.VALUE;\n              continue;\n            } else {\n              parser.stack.push(S.CLOSE_ARRAY);\n            }\n          }\n               if(c === Char.doubleQuote) parser.state = S.STRING;\n          else if(c === Char.openBrace) parser.state = S.OPEN_OBJECT;\n          else if(c === Char.openBracket) parser.state = S.OPEN_ARRAY;\n          else if(c === Char.t) parser.state = S.TRUE;\n          else if(c === Char.f) parser.state = S.FALSE;\n          else if(c === Char.n) parser.state = S.NULL;\n          else if(c === Char.minus) { // keep and continue\n            parser.numberNode += \"-\";\n          } else if(Char._0 <= c && c <= Char._9) {\n            parser.numberNode += String.fromCharCode(c);\n            parser.state = S.NUMBER_DIGIT;\n          } else               error(parser, \"Bad value\");\n        continue;\n\n        case S.CLOSE_ARRAY:\n          if(c === Char.comma) {\n            parser.stack.push(S.CLOSE_ARRAY);\n            closeValue(parser, 'onvalue');\n            parser.state  = S.VALUE;\n          } else if (c === Char.closeBracket) {\n            emitNode(parser, 'onclosearray');\n            this.depth--;\n            parser.state = parser.stack.pop() || S.VALUE;\n          } else if (isWhitespace(c))\n              continue;\n          else error(parser, 'Bad array');\n        continue;\n\n        case S.STRING:\n          if (parser.textNode === undefined) {\n            parser.textNode = \"\";\n          }\n\n          // thanks thejh, this is an about 50% performance improvement.\n          var starti              = i-1\n            , slashed = parser.slashed\n            , unicodeI = parser.unicodeI\n            ;\n          STRING_BIGLOOP: while (true) {\n            if (clarinet.DEBUG)\n              console.log(i,c,clarinet.STATE[parser.state]\n                         ,slashed);\n            // zero means \"no unicode active\". 1-4 mean \"parse some more\". end after 4.\n            while (unicodeI > 0) {\n              parser.unicodeS += String.fromCharCode(c);\n              c = chunk.charCodeAt(i++);\n              parser.position++;\n              if (unicodeI === 4) {\n                // TODO this might be slow? well, probably not used too often anyway\n                parser.textNode += String.fromCharCode(parseInt(parser.unicodeS, 16));\n                unicodeI = 0;\n                starti = i-1;\n              } else {\n                unicodeI++;\n              }\n              // we can just break here: no stuff we skipped that still has to be sliced out or so\n              if (!c) break STRING_BIGLOOP;\n            }\n            if (c === Char.doubleQuote && !slashed) {\n              parser.state = parser.stack.pop() || S.VALUE;\n              parser.textNode += chunk.substring(starti, i-1);\n              parser.position += i - 1 - starti;\n              break;\n            }\n            if (c === Char.backslash && !slashed) {\n              slashed = true;\n              parser.textNode += chunk.substring(starti, i-1);\n              parser.position += i - 1 - starti;\n              c = chunk.charCodeAt(i++);\n              parser.position++;\n              if (!c) break;\n            }\n            if (slashed) {\n              slashed = false;\n                   if (c === Char.n) { parser.textNode += '\\n'; }\n              else if (c === Char.r) { parser.textNode += '\\r'; }\n              else if (c === Char.t) { parser.textNode += '\\t'; }\n              else if (c === Char.f) { parser.textNode += '\\f'; }\n              else if (c === Char.b) { parser.textNode += '\\b'; }\n              else if (c === Char.u) {\n                // \\uxxxx. meh!\n                unicodeI = 1;\n                parser.unicodeS = '';\n              } else {\n                parser.textNode += String.fromCharCode(c);\n              }\n              c = chunk.charCodeAt(i++);\n              parser.position++;\n              starti = i-1;\n              if (!c) break;\n              else continue;\n            }\n\n            stringTokenPattern.lastIndex = i;\n            var reResult = stringTokenPattern.exec(chunk);\n            if (reResult === null) {\n              i = chunk.length+1;\n              parser.textNode += chunk.substring(starti, i-1);\n              parser.position += i - 1 - starti;\n              break;\n            }\n            i = reResult.index+1;\n            c = chunk.charCodeAt(reResult.index);\n            if (!c) {\n              parser.textNode += chunk.substring(starti, i-1);\n              parser.position += i - 1 - starti;\n              break;\n            }\n          }\n          parser.slashed = slashed;\n          parser.unicodeI = unicodeI;\n        continue;\n\n        case S.TRUE:\n          if (c === Char.r) parser.state = S.TRUE2;\n          else error(parser, 'Invalid true started with t'+ c);\n        continue;\n\n        case S.TRUE2:\n          if (c === Char.u) parser.state = S.TRUE3;\n          else error(parser, 'Invalid true started with tr'+ c);\n        continue;\n\n        case S.TRUE3:\n          if(c === Char.e) {\n            emit(parser, \"onvalue\", true);\n            parser.state = parser.stack.pop() || S.VALUE;\n          } else error(parser, 'Invalid true started with tru'+ c);\n        continue;\n\n        case S.FALSE:\n          if (c === Char.a) parser.state = S.FALSE2;\n          else error(parser, 'Invalid false started with f'+ c);\n        continue;\n\n        case S.FALSE2:\n          if (c === Char.l) parser.state = S.FALSE3;\n          else error(parser, 'Invalid false started with fa'+ c);\n        continue;\n\n        case S.FALSE3:\n          if (c === Char.s) parser.state = S.FALSE4;\n          else error(parser, 'Invalid false started with fal'+ c);\n        continue;\n\n        case S.FALSE4:\n          if (c === Char.e) {\n            emit(parser, \"onvalue\", false);\n            parser.state = parser.stack.pop() || S.VALUE;\n          } else error(parser, 'Invalid false started with fals'+ c);\n        continue;\n\n        case S.NULL:\n          if (c === Char.u) parser.state = S.NULL2;\n          else error(parser, 'Invalid null started with n'+ c);\n        continue;\n\n        case S.NULL2:\n          if (c === Char.l) parser.state = S.NULL3;\n          else error(parser, 'Invalid null started with nu'+ c);\n        continue;\n\n        case S.NULL3:\n          if(c === Char.l) {\n            emit(parser, \"onvalue\", null);\n            parser.state = parser.stack.pop() || S.VALUE;\n          } else error(parser, 'Invalid null started with nul'+ c);\n        continue;\n\n        case S.NUMBER_DECIMAL_POINT:\n          if(c === Char.period) {\n            parser.numberNode += \".\";\n            parser.state       = S.NUMBER_DIGIT;\n          } else error(parser, 'Leading zero not followed by .');\n        continue;\n\n        case S.NUMBER_DIGIT:\n          if(Char._0 <= c && c <= Char._9) parser.numberNode += String.fromCharCode(c);\n          else if (c === Char.period) {\n            if(parser.numberNode.indexOf('.')!==-1)\n              error(parser, 'Invalid number has two dots');\n            parser.numberNode += \".\";\n          } else if (c === Char.e || c === Char.E) {\n            if(parser.numberNode.indexOf('e')!==-1 ||\n               parser.numberNode.indexOf('E')!==-1 )\n               error(parser, 'Invalid number has two exponential');\n            parser.numberNode += \"e\";\n          } else if (c === Char.plus || c === Char.minus) {\n            if(!(p === Char.e || p === Char.E))\n              error(parser, 'Invalid symbol in number');\n            parser.numberNode += String.fromCharCode(c);\n          } else {\n            closeNumber(parser);\n            i--; // go back one\n            lockIncrements = true; // do not apply increments for a single cycle\n            parser.state = parser.stack.pop() || S.VALUE;\n          }\n        continue;\n\n        default:\n          error(parser, \"Unknown state: \" + parser.state);\n      }\n    }\n    if (parser.position >= parser.bufferCheckPosition)\n      checkBufferLength(parser);\n    return parser;\n  }\n\n})(typeof exports === \"undefined\" ? clarinet = {} : exports);\n", "//@ts-ignore\nimport clarinet from 'clarinet';\n\ntype ParseEvent = { type: string; key?: string; value?: any; err?: Error };\nexport type JsonNode =\n  | string\n  | boolean\n  | null\n  | number\n  | Map<string, JsonNode>\n  | JsonNode[];\n\nexport function parse(input: string): JsonNode {\n  const gen = processNode();\n  let out: JsonNode | undefined = undefined;\n  let err: Error | undefined = undefined;\n\n  function dispatch(obj: ParseEvent) {\n    try {\n      const res = gen.next(obj);\n      if (res.done) out = res.value as JsonNode;\n    } catch (e) {\n      err = e as Error;\n    }\n  }\n\n  const p = clarinet.parser();\n  p.onopenobject = (key: string) => dispatch({ type: 'openobject', key });\n  p.onopenarray = () => dispatch({ type: 'openarray' });\n  p.onkey = (key: string) => dispatch({ type: 'key', key });\n  p.onvalue = (value: string) => dispatch({ type: 'value', value });\n  p.oncloseobject = () => dispatch({ type: 'closeobject' });\n  p.onclosearray = () => dispatch({ type: 'closearray' });\n  p.onerror = (err: Error) => dispatch({ type: 'error', err });\n  //p.onend = () => dispatch({type:'end'});\n  gen.next();\n\n  p.write(input).close();\n  if (err) throw err;\n  return (out as unknown) as JsonNode;\n}\n\nexport function stringify(obj: JsonNode): string {\n  if (Array.isArray(obj)) return `[${obj.map(stringify).join(',')}]`;\n  if (obj instanceof Map)\n    return `{${[...obj]\n      .map(([k, v]) => JSON.stringify(k) + ':' + stringify(v))\n      .join(',')}}`;\n  return JSON.stringify(obj);\n}\n\nconst CLOSE_ARRAY = Symbol();\n\nfunction* processNode(): Generator<\n  any,\n  JsonNode | typeof CLOSE_ARRAY,\n  ParseEvent\n> {\n  const evt: ParseEvent = yield;\n  switch (evt.type) {\n    case 'value':\n      return evt.value;\n    case 'openobject':\n      const obj: Map<string, JsonNode> = new Map();\n      let key = evt.key;\n      if (key===undefined) yield; // must be 'objectclose'\n      while (key!==undefined) {\n        obj.set(key, (yield* processNode()) as JsonNode);\n        key = (yield).key; // 'key' or 'objectclose' event\n      }\n      return obj;\n    case 'openarray':\n      const arr: JsonNode[] = [];\n      let el: JsonNode | typeof CLOSE_ARRAY;\n      while (true) {\n        el = yield* processNode();\n        if (el === CLOSE_ARRAY) return arr;\n        arr.push(el);\n      }\n    case 'closearray':\n      return CLOSE_ARRAY;\n    case 'error':\n      throw evt.err;\n    default:\n      throw Error(`Unexpected ParseEvent ${evt.type}`);\n  }\n}\n", "// Copyright \u00A9 2024 Adrian Turcev\r\nconst parse = require('json-in-order').parse;\r\n\r\n//# Damon\r\nmodule.exports =\r\nclass Damon {\r\n    /**\r\n     * Creates an instance of Damon.\r\n     * @param {Boolean} pedantic\r\n     */\r\n    constructor(pedantic = false) {\r\n        const $ = this;\r\n        this.indentation = 4;\r\n        if ([true, false, undefined].indexOf(pedantic) == -1) {\r\n            throw new Error(\"@param {Boolean} pedantic\");\r\n        }\r\n        this.pedantic = pedantic;\r\n    }\r\n    /**\r\n     * Object-like ordered dictionaries declarations in js\r\n     * @param {TemplateStringsArray} strings\r\n     * @returns {damonValue}\r\n     */\r\n    template(strings) {\r\n        const $ = this;\r\n        var result = strings.raw[0];\r\n        for (let i = 1; i < strings.raw.length; i++) {\r\n            if (typeof arguments[i] == 'string') {\r\n                result += '\"' + arguments[i] + '\"';\r\n            } else {\r\n                result += arguments[i];\r\n            }\r\n            result += strings.raw[i];\r\n        }\r\n        let map = $._treeToMap($._damonToTree(result));\r\n        return map;\r\n    }\r\n\r\n    /**\r\n     * @param {string} damon\r\n     * @typedef {Map<string, damonValue>} damonMap\r\n     * @typedef {Array<damonValue>} damonArray\r\n     * @typedef {damonMap|damonArray|string|number|boolean|null} damonValue\r\n     * @returns damonValue\r\n     */\r\n    damonToMap(damon) {\r\n        const $ = this;\r\n        let treeOrPrimitive = $._damonToTree(damon);\r\n        if (\r\n            treeOrPrimitive === true\r\n            || treeOrPrimitive === false\r\n            || treeOrPrimitive === null\r\n            || typeof treeOrPrimitive === 'string'\r\n            || typeof treeOrPrimitive === 'number'\r\n        ) {\r\n            return treeOrPrimitive;\r\n        }\r\n        return $._treeToMap($._damonToTree(damon));\r\n    }\r\n\r\n    /**\r\n     * @param {string} damon\r\n     * @returns {string}\r\n     */\r\n    damonToJSON(damon) {\r\n        const $ = this;\r\n        return $.mapToJSON($.damonToMap(damon));\r\n    }\r\n\r\n    /**\r\n     * @param {string} json\r\n     * @returns {string}\r\n     */\r\n    jsonToDamon(json) {\r\n        const $ = this;\r\n        return $.mapToDamon($.jsonToMap(json), false);\r\n    }\r\n\r\n    /**\r\n     * @param {string} json\r\n     * @returns {damonValue}\r\n     */\r\n    jsonToMap(json) {\r\n        const $ = this;\r\n        var jsonLines = $._getLines(json, 'JSON');\r\n        // - Remove comments lines\r\n        jsonLines = jsonLines.filter(x => !(/^ *\\/\\//.test(x)));\r\n        // - Remove empty lines\r\n        jsonLines = jsonLines.filter(x => x != '');\r\n        // - Remove lines containing only indentation\r\n        jsonLines = jsonLines.filter(x => !/^[ \\t]+$/.test(x));\r\n        if (jsonLines.length == 1) {\r\n            if ([\"true\", \"false\", \"null\"].indexOf(jsonLines[0].trim()) > -1) {\r\n                return JSON.parse(jsonLines[0]);\r\n            } else if (/^\".*\"$/.test(jsonLines[0].trim())) {\r\n                try {\r\n                    return JSON.parse(jsonLines[0].trim());\r\n                } catch (error) {\r\n                    console.error(\"Error line number 1: not JSON-compliant, detailed error follows\");\r\n                    error.line = 1;\r\n                    error.language = \"JSON\";\r\n                    error.type = \"string\";\r\n                    throw error;\r\n                }\r\n            } else if (\r\n                isFinite(jsonLines[0])\r\n                && !isNaN(parseFloat(jsonLines[0]))\r\n                && Number.isFinite(jsonLines[0] * 1)\r\n                // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/NaN\r\n                && !Number.isNaN(jsonLines[0] * 1)\r\n            ) {\r\n                if (\r\n                    jsonLines[0].indexOf(0) == 0\r\n                    && jsonLines[0].length > 1\r\n                    && jsonLines[0].indexOf('.') !== 1\r\n                ) {\r\n                    let error = new Error(\"Error line number 1: leading 0\");\r\n                    error.line = 1;\r\n                    error.language = \"DAMON\";\r\n                    throw error;\r\n                }\r\n                try {\r\n                    return JSON.parse(jsonLines[0] * 1);\r\n                } catch (error) {\r\n                    console.error(\"Error line number 1: not JSON-compliant, detailed error follows\");\r\n                    error.line = 1;\r\n                    error.language = \"JSON\";\r\n                    error.type = \"number\";\r\n                    throw error;\r\n                }\r\n            } else if (jsonLines[0] * 1 === Infinity) {\r\n                // Make JSON.parse throw at Infinity\r\n                try {\r\n                    JSON.parse(jsonLines[0] * 1);\r\n                } catch (error) {\r\n                    console.error(\"Error line number 1: not JSON-compliant, detailed error follows\");\r\n                    error.line = 1;\r\n                    error.language = \"JSON\";\r\n                    error.type = \"infinity\";\r\n                    throw error;\r\n                }\r\n            } else {\r\n                return parse(json);\r\n            }\r\n        } else {\r\n            return parse(json);\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * @param {string} damon\r\n     * @param {string} [language='DAMON']\r\n     * @returns {Array<string>} damonLines\r\n     */\r\n    _getLines(damon, language = 'DAMON') {\r\n        if (['DAMON', 'JSON'].indexOf(language) == -1) {\r\n            throw new Error(\"Bad language argument, expected 'DAMON' or 'JSON'\");\r\n        }\r\n        if (damon === '') {\r\n            let error = new Error(\"Error line 1: empty string\");\r\n            error.line = 1;\r\n            error.language = language;\r\n            throw error;\r\n        }\r\n        if (\r\n            /[\\s]/.test(damon)\r\n            && damon.match(new RegExp(/[\\s]/))[0].length == damon.length\r\n        ) {\r\n            let error = new Error(\"Error line 1: string only contains whitespace\");\r\n            error.line = 1;\r\n            error.language = language;\r\n            throw error;\r\n        }\r\n        var delimiter = /\\r\\n/.test(damon) ? '\\r\\n' : '\\n',\r\n            damonLines = damon.split(delimiter);\r\n        if (/\\\\*\\n/.test(damon) && delimiter == '\\n') {\r\n            if (/[^\\\\]\\\\(\\\\\\\\)*\\n/.test(damon)) {\r\n                let errorLine = damon.split(/[^\\\\]\\\\(\\\\\\\\)*\\n/)[0].split('\\n').length;\r\n                let error = new Error(\"Error line \" + errorLine + \": oddly escaped newline\");\r\n                error.line = errorLine;\r\n                error.language = language;\r\n                throw error;\r\n            }\r\n            let reversedDamon = damon.split('').reverse().join(''),\r\n                reversedDamonLines = reversedDamon.split(/\\n/);\r\n            damonLines = reversedDamonLines.map((x) => x.split('').reverse().join('')).reverse();\r\n        }\r\n        return damonLines;\r\n    }\r\n\r\n    /**\r\n     * Offside-rule parsing\r\n     * @param {string} damon\r\n     * @typedef {{\r\n     *     content: string,\r\n     *     level: number,\r\n     *     id: string,\r\n     *     children: Array<treeNode>\r\n     * }} treeNode\r\n     * @typedef {{\r\n     *     headless: boolean,\r\n     *     damonOriginalLinesMapping: Array<number|null>\r\n     * } & treeNode} treeRoot\r\n     * @returns {treeRoot}\r\n     */\r\n    _damonToTree(damon) {\r\n        const $ = this;\r\n        let damonLines = $._getLines(damon),\r\n            damonOriginalLines = damonLines.slice(0);\r\n        // Let the shaving, begin!\r\n        // - Remove comments lines\r\n        damonLines = damonLines.filter(x => !(/^ *\\/\\//.test(x)));\r\n        // - Remove empty lines\r\n        damonLines = damonLines.filter(x => x != '');\r\n        // - Remove lines containing only indentation\r\n        damonLines = damonLines.filter(x => !/^[ \\t]+$/.test(x));\r\n        // Lone non-structural values\r\n        if (damonLines.length == 1) {\r\n            if ([\"true\", \"false\", \"null\"].indexOf(damonLines[0].trim()) > -1) {\r\n                return JSON.parse(damonLines[0]);\r\n            } else if (/^\".*\"$/.test(damonLines[0].trim())) {\r\n                try {\r\n                    return JSON.parse(damonLines[0].trim());\r\n                } catch (error) {\r\n                    console.error(\"Error line number 1: not JSON-compliant, detailed error follows\");\r\n                    error.line = 1;\r\n                    error.language = \"JSON\";\r\n                    error.type = \"string\";\r\n                    throw error;\r\n                }\r\n            } else if (\r\n                isFinite(damonLines[0])\r\n                && !isNaN(parseFloat(damonLines[0]))\r\n                && Number.isFinite(damonLines[0] * 1)\r\n            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/NaN\r\n                && !Number.isNaN(damonLines[0] * 1)\r\n            ) {\r\n                if (\r\n                    damonLines[0].indexOf(0) == 0\r\n                    && damonLines[0].length > 1\r\n                    && damonLines[0].indexOf('.') !== 1\r\n                ) {\r\n                    let error = new Error(\"Error line number 1: leading 0\");\r\n                    error.line = 1;\r\n                    error.language = \"DAMON\";\r\n                    throw error;\r\n                }\r\n                try {\r\n                    return JSON.parse(damonLines[0] * 1);\r\n                } catch (error) {\r\n                    console.error(\"Error line number 1: not JSON-compliant, detailed error follows\");\r\n                    error.line = 1;\r\n                    error.language = \"JSON\";\r\n                    error.type = \"number\";\r\n                    throw error;\r\n                }\r\n            } else if (damonLines[0] * 1 === Infinity) {\r\n                // Make JSON.parse throw at Infinity\r\n                try {\r\n                    JSON.parse(damonLines[0] * 1);\r\n                } catch (error) {\r\n                    console.error(\"Error line number 1: not JSON-compliant, detailed error follows\");\r\n                    error.line = 1;\r\n                    error.language = \"JSON\";\r\n                    error.type = \"infinity\";\r\n                    throw error;\r\n                }\r\n            }\r\n        }\r\n        // Keep a mapping\r\n        let damonLinesIndex = 0,\r\n            damonOriginalLinesMapping = [];\r\n        for (let i = 0, c = damonOriginalLines.length; i < c; i++) {\r\n            if (damonLines.slice(damonLinesIndex).indexOf(damonOriginalLines[i]) > -1) {\r\n                damonOriginalLinesMapping[i] = damonLines.slice(damonLinesIndex).indexOf(damonOriginalLines[i]);\r\n            } else {\r\n                damonOriginalLinesMapping[i] = null;\r\n            }\r\n        }\r\n        let tabsMatchingRegex = new RegExp('^(\\\\t)+');\r\n        for (let i = 0, c = damonLines.length; i < c; i++) {\r\n            // - Replacing leading tabs\r\n            if (tabsMatchingRegex.test(damonLines[i])) {\r\n                const tabsPaddingLength = damonLines[i].match(tabsMatchingRegex)[0].length;\r\n                for (let z = 0, x = tabsPaddingLength; z < x; z++) {\r\n                    damonLines[i] = damonLines[i].replace('\t', ' '.repeat($.indentation));\r\n                }\r\n            }\r\n            // Throwing at implicit-nulls trailing whitespaces\r\n            // Necessary to avoid implicit cohersion\r\n            // Simply trimming might partly-erase implicit-keys\r\n            if (\r\n                !/^ *- $/.test(damonLines[i])\r\n                && /[ \\t]+$/.test(damonLines[i])\r\n            ) {\r\n                let error = new Error(\r\n                    \"Error line \" + (damonOriginalLinesMapping.indexOf(i) + 1) + \": trailing whitespace\"\r\n                );\r\n                error.line = damonOriginalLinesMapping.indexOf(i) + 1;\r\n                error.language = \"DAMON\";\r\n                throw error;\r\n            }\r\n        }\r\n        // - Try to fix indentation\r\n        let indentationMatchingRegex = new RegExp('^(' + ' '.repeat($.indentation) + ')+');\r\n        if (\r\n            indentationMatchingRegex.test(damonLines[0])\r\n        ) {\r\n            let initialPadding = damonLines[0].match(indentationMatchingRegex)[0].length,\r\n                trimmable = true;\r\n            for (let i = 0, c = damonLines.length; i < c; i++) {\r\n                if (\r\n                    indentationMatchingRegex.test(damonLines[i])\r\n                    && damonLines[i].match(indentationMatchingRegex)[0].length >= initialPadding\r\n                ) {\r\n                    damonLines[i] = damonLines[i].slice(initialPadding);\r\n                } else {\r\n                    trimmable = false;\r\n                }\r\n            }\r\n            if (!trimmable) {\r\n                let error = new Error(\"Error line 1: bad formatting\");\r\n                error.line = 1;\r\n                error.language = \"DAMON\";\r\n                throw error;\r\n            }\r\n        } else if (\r\n            indentationMatchingRegex.test(damonLines[1])\r\n            && damonLines[1].match(indentationMatchingRegex)[0].length > $.indentation\r\n        ) {\r\n            let initialPadding = damonLines[1].match(indentationMatchingRegex)[0].length - $.indentation,\r\n                trimmable = true;\r\n            for (let i = 1, c = damonLines.length; i < c; i++) {\r\n                if (\r\n                    indentationMatchingRegex.test(damonLines[i])\r\n                    && damonLines[i].match(indentationMatchingRegex)[0].length >= initialPadding\r\n                ) {\r\n                    damonLines[i] = damonLines[i].slice(initialPadding);\r\n                } else {\r\n                    trimmable = false;\r\n                }\r\n            }\r\n            if (!trimmable) {\r\n                let error = new Error(\"Error line 2: bad formatting\");\r\n                error.line = 2;\r\n                error.language = \"DAMON\";\r\n                throw error;\r\n            }\r\n        }\r\n        // - Headless support\r\n        let headless = false;\r\n        if (damonLines.length > 1) {\r\n            for (let i = 0, c = damonLines.length; i < c; i++) {\r\n                if (\r\n                    i !== 0\r\n                    && /^- /.test(damonLines[i])\r\n                ) {\r\n                    headless = true;\r\n                }\r\n            }\r\n        }\r\n        if (\r\n            !/^- \\{\\}$/.test(damonLines[0])\r\n            && !/^- \\[\\]$/.test(damonLines[0])\r\n        ) {\r\n            headless = true;\r\n        }\r\n        if (headless) {\r\n            for (let i = 0, c = damonLines.length; i < c; i++) {\r\n                damonLines[i] = ' '.repeat($.indentation) + damonLines[i];\r\n            }\r\n            damonLines.unshift('- {}');\r\n        }\r\n\r\n        var treeRoot = {\r\n            content: damonLines[0],\r\n            level: 0,\r\n            id: 0,\r\n            children: [],\r\n            headless: headless,\r\n            damonOriginalLinesMapping: damonOriginalLinesMapping\r\n        };\r\n        var previousListItem = treeRoot;\r\n        if (\r\n            !/^- /.test(damonLines[0].trimStart())\r\n            || (\r\n                /^ +/.test(damonLines[0])\r\n                && (\r\n                    damonLines[0].match(/^ +/)[0].length % $.indentation != 0\r\n                    || (\r\n                        damonLines[0].match(/^ +/)[0].length != $.indentation\r\n                    )\r\n                )\r\n            )\r\n        ) {\r\n            let error = new Error(\"Error line \" + ((headless * 1) + 1) + \": bad formatting\");\r\n            error.line = (headless * 1) + 1;\r\n            error.language = \"DAMON\";\r\n            throw error;\r\n        }\r\n        damonLines.shift();\r\n        for (let i = 0, c = damonLines.length; i < c; i++) {\r\n            if (\r\n                !/^- /.test(damonLines[i].trimStart())\r\n                || (\r\n                    /^ +/.test(damonLines[i])\r\n                    && (\r\n                        damonLines[i].match(/^ +/)[0].length % $.indentation != 0\r\n                        || (\r\n                            i == 0\r\n                            && damonLines[i].match(/^ +/)[0].length != $.indentation\r\n                        ) || (\r\n                            i != 0\r\n                            && /^- /.test(damonLines[i - 1])\r\n                            && damonLines[i].match(/^ +/)[0].length != $.indentation\r\n                        ) || (\r\n                            i != 0\r\n                            && !/^- /.test(damonLines[i - 1])\r\n                            && (\r\n                                damonLines[i].match(/^ +/)[0].length\r\n                                > (damonLines[i - 1].match(/^ +/)[0].length + $.indentation)\r\n                            )\r\n                        )\r\n                    )\r\n                )\r\n            ) {\r\n                let error = new Error(\r\n                    \"Error line \" + (damonOriginalLinesMapping.indexOf(i) + 1) + \": bad formatting\"\r\n                );\r\n                error.line = damonOriginalLinesMapping.indexOf(i) + 1;\r\n                error.language = \"DAMON\";\r\n                throw error;\r\n            }\r\n            /* jshint -W083 */\r\n            let listItem = {\r\n                    content: damonLines[i].trimStart().slice(2),\r\n                    level: 1 + (damonLines[i].match(/^ +/)[0].length / $.indentation),\r\n                    id: '',\r\n                    children: []\r\n                };\r\n            if (previousListItem === treeRoot) {\r\n                listItem.id = treeRoot.children.length + 1;\r\n                treeRoot.children.push(listItem);\r\n            } else if (previousListItem.level === listItem.level) {\r\n                var parentListItem = $._findListItemCommonDirectParent(previousListItem, treeRoot);\r\n                if (parentListItem.level == 0) {\r\n                    listItem.id = parentListItem.children.length + 1;\r\n                } else {\r\n                    listItem.id = parentListItem.id + '-' + (parentListItem.children.length + 1);\r\n                }\r\n                parentListItem.children.push(listItem);\r\n            } else if (previousListItem.level > listItem.level) {\r\n                var commonAncestor = $._findListItemCommonAncestor(previousListItem, treeRoot, listItem.level);\r\n                if (commonAncestor.level == 0) {\r\n                    listItem.id = commonAncestor.children.length + 1;\r\n                } else {\r\n                    listItem.id = commonAncestor.id + '-' + (commonAncestor.children.length + 1);\r\n                }\r\n                commonAncestor.children.push(listItem);\r\n            } else if (previousListItem.level < listItem.level) {\r\n                var grandParentListItem = $._findListItemCommonDirectParent(previousListItem, treeRoot);\r\n                let previousListItemIndex = grandParentListItem.children.indexOf(previousListItem);\r\n                let previousListItemId =\r\n                        grandParentListItem.children[previousListItemIndex].id,\r\n                    nextTitleNumber = grandParentListItem.children[previousListItemIndex].children.length + 1;\r\n                listItem.id = previousListItemId + '-' + nextTitleNumber;\r\n                grandParentListItem.children[previousListItemIndex].children.push(listItem);\r\n            }\r\n            previousListItem = listItem;\r\n        }\r\n        return treeRoot;\r\n    }\r\n\r\n    /**\r\n     * @param {any} listItem\r\n     * @param {{ children: string | any[]; }} possibleParent\r\n     * @return {object|string} DOM\r\n     */\r\n    _findListItemCommonDirectParent(listItem, possibleParent) {\r\n        const $ = this;\r\n        if (possibleParent.children.indexOf(listItem) > -1) {\r\n            return possibleParent;\r\n        } else {\r\n            var parent;\r\n            for (let i = possibleParent.children.length - 1, c = 0; i >= c; i--) {\r\n                parent = $._findListItemCommonDirectParent(listItem, possibleParent.children[i]);\r\n                if (parent) {\r\n                    return parent;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param {any} listItem\r\n     * @param {{ children: string | any[]; }} possibleParent\r\n     * @param {number} level\r\n     * @return {object|string} DOM\r\n     */\r\n    _findListItemCommonAncestor(listItem, possibleParent, level) {\r\n        const $ = this;\r\n        var parent = $._findListItemCommonDirectParent(listItem, possibleParent);\r\n        if (parent.level < level) {\r\n            return parent;\r\n        } else {\r\n            return $._findListItemCommonAncestor(parent, possibleParent, level);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * JSON primitives wrapping\r\n     * @param {treeRoot} damonTree\r\n     * @return {damonMap | damonArray}\r\n     */\r\n    _treeToMap(damonTree) {\r\n        const $ = this;\r\n        var treeItemIndex = 0;\r\n        if (damonTree.content == '- {}') {\r\n            let map = new Map();\r\n            map.damonOriginalLinesMapping = damonTree.damonOriginalLinesMapping;\r\n            if (damonTree.headless) {\r\n                map.headless = true;\r\n            }\r\n            return _recurse(damonTree, map);\r\n        } else if (damonTree.content == '- []') {\r\n            let array = [];\r\n            array.damonOriginalLinesMapping = damonTree.damonOriginalLinesMapping;\r\n            return _recurse(damonTree, array);\r\n        }\r\n        /**\r\n         * @param {Object} tree\r\n         * @param {Map<string, any>|Array<any>} jsonMap\r\n         * @returns {Map<string, any>|Array<any>}\r\n         */\r\n        function _recurse(tree, jsonMap) {\r\n            if (\r\n                typeof tree !== 'object'\r\n                || tree == null\r\n                || Array.isArray(tree)\r\n            ) {\r\n                let errorLine =\r\n                    (damonTree.headless * -1)\r\n                    + damonTree.damonOriginalLinesMapping.indexOf(treeItemIndex - 1)\r\n                    + 2;\r\n                let error = new Error(\"Error line number \"+ errorLine + \": @param { {} } tree\");\r\n                error.line = errorLine;\r\n                error.language = \"DAMON\";\r\n                throw error;\r\n            }\r\n            if (\r\n                typeof jsonMap === 'object'\r\n                && jsonMap !== null\r\n                && !Array.isArray(jsonMap)\r\n                && jsonMap instanceof Map\r\n                && jsonMap.constructor === Map\r\n            ) { // {}\r\n                _mapHandler(tree, jsonMap);\r\n            } else if (Array.isArray(jsonMap)) {\r\n                // []\r\n                _listHandler(tree, jsonMap);\r\n            } else {\r\n                let errorLine =\r\n                    (damonTree.headless * -1)\r\n                    + damonTree.damonOriginalLinesMapping.indexOf(treeItemIndex - 1)\r\n                    + 2;\r\n                let error = new Error(\"Error line number \" + errorLine + \": @param { {} | [] } jsonMap\");\r\n                error.line = errorLine;\r\n                error.language = \"DAMON\";\r\n                throw error;\r\n            }\r\n            return jsonMap;\r\n        }\r\n\r\n        /**\r\n         * @param {Object} tree\r\n         * @param {Map<string, any>|Array<any>} jsonMap\r\n         */\r\n        function _mapHandler(tree, jsonMap) {\r\n            for (let i = 0, c = tree.children.length; i < c; i++) {\r\n                treeItemIndex++;\r\n                if (tree.children[i].content.length == 0) {\r\n                    // implicit value\r\n                    let errorType = \"\";\r\n                    if (tree.children[i].children.length > 0) {\r\n                        errorType = \"implicit map key\";\r\n                        jsonMap.set(\"\", new Map());\r\n                        // Storing formatting for auto-formatting\r\n                        if (jsonMap.implicitMaps === undefined) {\r\n                            jsonMap.implicitMaps = [];\r\n                        }\r\n                        jsonMap.implicitMaps.push(\"\");\r\n                        _recurse(tree.children[i], jsonMap.get(\"\"));\r\n                    } else {\r\n                        errorType = \"implicit null key\";\r\n                        jsonMap.set(\"\", null);\r\n                        // Storing formatting for auto-formatting\r\n                        if (jsonMap.implicitNulls ===  undefined) {\r\n                            jsonMap.implicitNulls = [];\r\n                        }\r\n                        jsonMap.implicitNulls.push(\"\");\r\n                    }\r\n                } else {\r\n                    let text = tree.children[i].content,\r\n                        errorType = \"key\";\r\n                    // Catching JSON.stringify() and JSON.parse() throws\r\n                    try {\r\n                        if (\r\n                            /^.*: +\\[/.test(text)\r\n                            && text[text.length - 1] == ']'\r\n                        ) {\r\n                            if (\r\n                                /: +\\[ *\\]$/.test(text)\r\n                            ) {\r\n                                let key =\r\n                                    JSON.parse(\r\n                                        `[\"${text.slice(0, -1 * text.match(/: +\\[ *\\]$/)[0].length)}\"]`\r\n                                    )[0];\r\n                                jsonMap.set(key, []);\r\n                                if (tree.children[i].children.length > 0) {\r\n                                    _recurse(tree.children[i], jsonMap.get(key));\r\n                                }\r\n                            } else {\r\n                                // Normalizing\r\n                                let redundantWhitespaceMatchingRegex = new RegExp(/: +\\[/g),\r\n                                    splitString = text.slice(0, -1).split(redundantWhitespaceMatchingRegex),\r\n                                    textMatchesPlusOne = text.match(redundantWhitespaceMatchingRegex).concat(['']),\r\n                                    splitStringWithMatches = splitString.map((x, i) => x + textMatchesPlusOne[i]),\r\n                                    shortestPossibleKey = '',\r\n                                    longestPossibleArray = [];\r\n                                for (let j = 0, k = splitString.length; j < k; j++) {\r\n                                    try {\r\n                                        let concatenation;\r\n                                        if (j == 0) {\r\n                                            concatenation = splitString[0];\r\n                                        } else {\r\n                                            concatenation =\r\n                                                splitStringWithMatches.slice(0, j).join('')\r\n                                                + splitString[j];\r\n                                        }\r\n                                        shortestPossibleKey = JSON.parse(`[\"${concatenation}\"]`)[0];\r\n                                        errorType = \"list\";\r\n                                        longestPossibleArray =\r\n                                            JSON.parse(`[${splitStringWithMatches.slice(j + 1).join('')}]`);\r\n                                        if (Array.isArray(longestPossibleArray)) {\r\n                                            break;\r\n                                        }\r\n                                    } catch (error) {\r\n                                        // Doesn't matter until...\r\n                                        if (j == k - 2) {\r\n                                            let errorLine =\r\n                                                (damonTree.headless * -1)\r\n                                                + damonTree.damonOriginalLinesMapping.indexOf(treeItemIndex - 1)\r\n                                                + 2;\r\n                                            let error = new Error(\r\n                                                \"Error line number \" + errorLine + \": invalid inline list\"\r\n                                            );\r\n                                            error.line = errorLine;\r\n                                            error.language = \"DAMON\";\r\n                                            throw error;\r\n                                        }\r\n                                    }\r\n                                }\r\n                                // Primitives check here\r\n                                let arrayOfPrimitives =\r\n                                    longestPossibleArray.every(function (item) {\r\n                                        if (item === true) {\r\n                                            return true;\r\n                                        } else if (item === false) {\r\n                                            return true;\r\n                                        } else if (item === null) {\r\n                                            return true;\r\n                                        } else if (typeof item == 'string') {\r\n                                            return true;\r\n                                        } else if (\r\n                                            isFinite(item)\r\n                                            && !isNaN(parseFloat(item))\r\n                                            && Number.isFinite(item * 1)\r\n                        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/NaN\r\n                                            && !Number.isNaN(item * 1)\r\n                                        ) { // Number\r\n                                            return true;\r\n                                        } else {\r\n                                            return false;\r\n                                        }\r\n                                    });\r\n                                if (arrayOfPrimitives) {\r\n                                    // No nesting, fits on an archivable line\r\n                                    jsonMap.set(shortestPossibleKey, longestPossibleArray);\r\n                                    // Storing formatting for auto-formatting options\r\n                                    if (jsonMap.damonInlineArrays === undefined) {\r\n                                        jsonMap.damonInlineArrays = [];\r\n                                    }\r\n                                    jsonMap.damonInlineArrays.push(shortestPossibleKey);\r\n                                } else {\r\n                                    let errorLine =\r\n                                        + (damonTree.headless * -1)\r\n                                        + damonTree.damonOriginalLinesMapping.indexOf(treeItemIndex - 1)\r\n                                        + 2;\r\n                                    let error = new Error(\r\n                                        \"Error line number \" + errorLine + \": no nesting in inline lists\"\r\n                                    );\r\n                                    error.line = errorLine;\r\n                                    error.language = \"DAMON\";\r\n                                    throw error;\r\n                                }\r\n                                if (tree.children[i].children.length > 0) {\r\n                                    let errorLine =\r\n                                        (damonTree.headless * -1)\r\n                                        + damonTree.damonOriginalLinesMapping.indexOf(treeItemIndex - 1)\r\n                                        + 3;\r\n                                    let error = new Error(\r\n                                        \"Error line number \" + errorLine + \": inline lists can't have children\"\r\n                                    );\r\n                                    error.line = errorLine;\r\n                                    error.language = \"DAMON\";\r\n                                    throw error;\r\n                                }\r\n                            }\r\n                        } else if (\r\n                            /: +\\{ *\\}$/.test(text)\r\n                        ) { // Map\r\n                            let key =\r\n                                JSON.parse(\r\n                                    `[\"${text.slice(0, -1 * text.match(/: +\\{ *\\}$/)[0].length)}\"]`\r\n                                )[0];\r\n                            jsonMap.set(key, new Map());\r\n                            _recurse(tree.children[i], jsonMap.get(key));\r\n                        } else {\r\n                            let implicitProperty = false;\r\n                            if (\r\n                                /^.*: /.test(text)\r\n                                && text.split(new RegExp(/: +/))[text.split(new RegExp(/: +/)).length - 1] === \"true\"\r\n                            ) { // True\r\n                                let lastTextMatch =\r\n                                        text.match(new RegExp(/: +/g))[text.match(new RegExp(/: +/g)).length - 1],\r\n                                    key = JSON.parse(`[\"${text.slice(0, (-1 * lastTextMatch.length) -4)}\"]`)[0];\r\n                                jsonMap.set(key, true);\r\n                            } else if (\r\n                                /^.*: /.test(text)\r\n                                && text.split(new RegExp(/: +/))[text.split(new RegExp(/: +/)).length - 1] === \"false\"\r\n                            ) { // False\r\n                                let lastTextMatch =\r\n                                        text.match(new RegExp(/: +/g))[text.match(new RegExp(/: +/g)).length - 1],\r\n                                    key = JSON.parse(`[\"${text.slice(0, (-1 * lastTextMatch.length) -5)}\"]`)[0];\r\n                                jsonMap.set(key, false);\r\n                            } else if (\r\n                                /^.*: /.test(text)\r\n                                && text.split(new RegExp(/: +/))[text.split(new RegExp(/: +/)).length - 1] === \"null\"\r\n                            ) { // Null\r\n                                let lastTextMatch =\r\n                                        text.match(new RegExp(/: +/g))[text.match(new RegExp(/: +/g)).length - 1],\r\n                                    key = JSON.parse(`[\"${text.slice(0, (-1 * lastTextMatch.length) -4)}\"]`)[0];\r\n                                jsonMap.set(key, null);\r\n                            } else if (\r\n                                /^.*: +\"/.test(text)\r\n                                && text[text.length - 1] == '\"'\r\n                            ) { // String\r\n                                let separatorMatches = text.match(new RegExp(/: +\"/g));\r\n                                if (\r\n                                    separatorMatches.length == 1\r\n                                ) {\r\n                                    let key =\r\n                                        JSON.parse(\r\n                                            `[\"${text.split(separatorMatches[0])[0]}\"]`\r\n                                        )[0];\r\n                                    errorType = \"string\";\r\n                                    let childText =\r\n                                        JSON.parse(\r\n                                            `[\"${\r\n                                                text.split(separatorMatches[0]).slice(1).join('').slice(0, -1)\r\n                                            }\"]`\r\n                                        )[0];\r\n                                    jsonMap.set(key, childText);\r\n                                } else if (\r\n                                    separatorMatches.length == 2\r\n                                    && /: +\"$/.test(text)\r\n                                ) {\r\n                                    let key =\r\n                                        JSON.parse(\r\n                                            `[\"${text.split(separatorMatches[0])[0]}\"]`\r\n                                        )[0];\r\n                                    errorType = \"string\";\r\n                                    let childText =\r\n                                        JSON.parse(\r\n                                            `[\"${\r\n                                                text.split(separatorMatches[0]).slice(1).join('') + ': '\r\n                                            }\"]`\r\n                                        )[0];\r\n                                    jsonMap.set(key, childText);\r\n                                } else {\r\n                                    let errorLine =\r\n                                        + (damonTree.headless * -1)\r\n                                        + damonTree.damonOriginalLinesMapping.indexOf(treeItemIndex - 1)\r\n                                        + 2;\r\n                                    let error = new Error(\r\n                                        \"Error line number \" + errorLine + \": unescaped double quote\"\r\n                                    );\r\n                                    error.line = errorLine;\r\n                                    error.language = \"DAMON\";\r\n                                    throw error;\r\n                                }\r\n                            } else if (\r\n                                /^.*: /.test(text)\r\n                                && isFinite(text.split(': ')[text.split(': ').length - 1])\r\n                                && !isNaN(parseFloat(text.split(': ')[text.split(': ').length - 1]))\r\n                                && Number.isFinite(text.split(': ')[text.split(': ').length - 1] * 1)\r\n                    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/NaN\r\n                                && !Number.isNaN(text.split(': ')[text.split(': ').length - 1] * 1)\r\n                            ) { // Number\r\n                                let key = JSON.parse(`[\"${text.split(': ').slice(0, -1).join(': ')}\"]`)[0];\r\n                                errorType = \"number\";\r\n                                let separatorMatches = text.match(new RegExp(/: +/g)),\r\n                                    lastSeparatorMatch = separatorMatches[separatorMatches.length - 1],\r\n                                    value = text.split(lastSeparatorMatch)[text.split(lastSeparatorMatch).length - 1];\r\n                                if (\r\n                                    value.indexOf(0) == 0\r\n                                    && value.length > 1\r\n                                    && value.indexOf('.') !== 1\r\n                                ) {\r\n                                    let errorLine =\r\n                                        (damonTree.headless * -1)\r\n                                        + damonTree.damonOriginalLinesMapping.indexOf(treeItemIndex - 1)\r\n                                        + 2;\r\n                                    let error = new Error(\"Error line number \" + errorLine + \": leading 0\");\r\n                                    error.line = errorLine;\r\n                                    error.language = \"DAMON\";\r\n                                    throw error;\r\n                                }\r\n                                let number = JSON.parse(`[${text.split(': ')[text.split(': ').length - 1] * 1}]`)[0];\r\n                                jsonMap.set(key, number);\r\n                            } else if (\r\n                                /^.*: /.test(text)\r\n                                && (\r\n                                    text.split(new RegExp(/: +/))[text.split(new RegExp(/: +/)).length - 1] * 1\r\n                                ) === Infinity\r\n                            ) {\r\n                                let key = JSON.parse(`[\"${text.split(': ').slice(0, -1).join(': ')}\"]`)[0];\r\n                                errorType = \"infinity\";\r\n                                // JSON.parse() throws at Infinity\r\n                                let number = JSON.parse(`[${text.split(': ')[text.split(': ').length - 1] * 1}]`);\r\n                            } else {\r\n                                // Value re-checks\r\n                                // Hoisting worth using returns above?\r\n                                let validValue = false,\r\n                                    valueLength = 0;\r\n                                if (\r\n                                    /\\[ *\\]$/.test(text)\r\n                                ) {\r\n                                    validValue = true;\r\n                                    valueLength = text.match(new RegExp(/\\[ *\\]$/g))[0].length;\r\n                                }\r\n                                if (\r\n                                    /\\{ *\\}$/.test(text)\r\n                                ) {\r\n                                    validValue = true;\r\n                                    valueLength = text.match(new RegExp(/\\{ *\\}$/g))[0].length;\r\n                                }\r\n                                if (\r\n                                    /true$/.test(text)\r\n                                ) {\r\n                                    validValue = true;\r\n                                    valueLength = 4;\r\n                                }\r\n                                if (\r\n                                    /false$/.test(text)\r\n                                ) {\r\n                                    validValue = true;\r\n                                    valueLength = 5;\r\n                                }\r\n                                if (\r\n                                    /null$/.test(text)\r\n                                ) {\r\n                                    validValue = true;\r\n                                    valueLength = 4;\r\n                                }\r\n                                if (\r\n                                    /\".*\"$/.test(text)\r\n                                ) {\r\n                                    validValue = true;\r\n                                    valueLength = text.match(new RegExp(/\".*\"$/g))[0].length;\r\n                                }\r\n                                if (!validValue) {\r\n                                    let accumulator = '';\r\n                                    for (let i = text.length - 1; i > -1; i--) {\r\n                                        accumulator = text[i].concat(accumulator);\r\n                                        if (\r\n                                            isFinite(accumulator)\r\n                                            && !isNaN(parseFloat(accumulator))\r\n                                            && Number.isFinite(accumulator * 1)\r\n                    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/NaN\r\n                                            && !Number.isNaN(accumulator * 1)\r\n                                        ) {\r\n                                            if (!/[ \\t]/.test(text[i])) {\r\n                                                break;\r\n                                            }\r\n                                            validValue = true;\r\n                                            valueLength = accumulator.length;\r\n                                        } else {\r\n                                            break;\r\n                                        }\r\n                                    }\r\n                                }\r\n                                if (validValue) {\r\n                                    // valid value\r\n                                    JSON.parse(`[\"${text.slice(0, -1 * valueLength)}\"]`)[0];\r\n                                    // valid key\r\n                                    if ($.pedantic) {\r\n                                        // pedantic\r\n                                        // missing separator error\r\n                                        let errorLine =\r\n                                            (damonTree.headless * -1)\r\n                                            + damonTree.damonOriginalLinesMapping.indexOf(treeItemIndex);\r\n                                        let error = new Error(\r\n                                            \"Error line number \" + errorLine + \": missing separator\"\r\n                                        );\r\n                                        error.line = errorLine;\r\n                                        error.language = \"DAMON\";\r\n                                        error.errorType = \"pedantic\";\r\n                                        throw error;\r\n                                    } else {\r\n                                        // implicit value\r\n                                        implicitProperty = true;\r\n                                        if (tree.children[i].children.length > 0) {\r\n                                            errorType = \"implicit map key\";\r\n                                            let key = JSON.parse(`[\"${text}\"]`)[0];\r\n                                            jsonMap.set(key, new Map());\r\n                                            // Storing formatting for auto-formatting\r\n                                            if (jsonMap.implicitMaps === undefined) {\r\n                                                jsonMap.implicitMaps = [];\r\n                                            }\r\n                                            jsonMap.implicitMaps.push(key);\r\n                                            _recurse(tree.children[i], jsonMap.get(key));\r\n                                        } else {\r\n                                            errorType = \"implicit null key\";\r\n                                            let key = JSON.parse(`[\"${text}\"]`)[0];\r\n                                            jsonMap.set(key, null);\r\n                                            // Storing formatting for auto-formatting\r\n                                            if (jsonMap.implicitNulls ===  undefined) {\r\n                                                jsonMap.implicitNulls = [];\r\n                                            }\r\n                                            jsonMap.implicitNulls.push(key);\r\n                                        }\r\n                                    }\r\n                                } else {\r\n                                    // invalid value\r\n                                    let string = JSON.parse(`[\"${text.slice(0, -1 * valueLength)}\"]`)[0];\r\n                                    // valid as a key\r\n                                    if ($.pedantic) {\r\n                                        // pedantic\r\n                                        if (/: +$/.test(string)) {\r\n                                            // key end has separator\r\n                                            // bad value\r\n                                            let errorLine =\r\n                                                (damonTree.headless * -1)\r\n                                                + damonTree.damonOriginalLinesMapping.indexOf(treeItemIndex);\r\n                                            let error = new Error(\"Error line number \" + errorLine + \": bad value\");\r\n                                            error.line = errorLine;\r\n                                            error.language = \"DAMON\";\r\n                                            error.errorType = \"pedantic\";\r\n                                            throw error;\r\n                                        } else {\r\n                                            // key end lacks separator\r\n                                            // missing separator\r\n                                            let errorLine =\r\n                                                (damonTree.headless * -1)\r\n                                                + damonTree.damonOriginalLinesMapping.indexOf(treeItemIndex);\r\n                                            let error = new Error(\r\n                                                \"Error line number \" + errorLine + \": missing separator\"\r\n                                            );\r\n                                            error.line = errorLine;\r\n                                            error.language = \"DAMON\";\r\n                                            error.errorType = \"pedantic\";\r\n                                            throw error;\r\n                                        }\r\n                                    } else {\r\n                                        // not pedantic\r\n                                        // use as implicit\r\n                                        implicitProperty = true;\r\n                                        if (tree.children[i].children.length > 0) {\r\n                                            errorType = \"implicit map key\";\r\n                                            let key = JSON.parse(`[\"${text}\"]`)[0];\r\n                                            jsonMap.set(key, new Map());\r\n                                            // Storing formatting for auto-formatting\r\n                                            if (jsonMap.implicitMaps === undefined) {\r\n                                                jsonMap.implicitMaps = [];\r\n                                            }\r\n                                            jsonMap.implicitMaps.push(key);\r\n                                            _recurse(tree.children[i], jsonMap.get(key));\r\n                                        } else {\r\n                                            errorType = \"implicit null key\";\r\n                                            let key = JSON.parse(`[\"${text}\"]`)[0];\r\n                                            jsonMap.set(key, null);\r\n                                            // Storing formatting for auto-formatting\r\n                                            if (jsonMap.implicitNulls ===  undefined) {\r\n                                                jsonMap.implicitNulls = [];\r\n                                            }\r\n                                            jsonMap.implicitNulls.push(key);\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                            if (\r\n                                !implicitProperty\r\n                                && tree.children[i].children.length > 0\r\n                            ) {\r\n                                let errorLine =\r\n                                    (damonTree.headless * -1)\r\n                                    + damonTree.damonOriginalLinesMapping.indexOf(treeItemIndex - 1)\r\n                                    + 3;\r\n                                let error = new Error(\r\n                                    \"Error line number \" + errorLine + \": missing container or excess indentation\"\r\n                                );\r\n                                error.line = errorLine;\r\n                                error.language = \"DAMON\";\r\n                                throw error;\r\n                            }\r\n                        }\r\n                    } catch (error) {\r\n                        if (error.language === undefined) {\r\n                            let errorLine =\r\n                                (damonTree.headless * -1)\r\n                                + damonTree.damonOriginalLinesMapping.indexOf(treeItemIndex - 1)\r\n                                + 2;\r\n                            console.error(\r\n                                \"Error line number \" + errorLine + \": not JSON-compliant, detailed error follows\"\r\n                            );\r\n                            error.line = errorLine;\r\n                            error.language = \"JSON\";\r\n                            error.type = errorType;\r\n                        }\r\n                        throw error;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         * @param {Object} tree\r\n         * @param {Map<string, any>|Array<any>} jsonMap\r\n         */\r\n        function _listHandler(tree, jsonMap) {\r\n            for (let i = 0, c = tree.children.length; i < c; i++) {\r\n                treeItemIndex++;\r\n                if (tree.children[i].content.length) {\r\n                    let text = tree.children[i].content;\r\n                    if (\r\n                        /^[ \\t]*\\[/.test(text)\r\n                        && text[text.length - 1] == ']'\r\n                    ) {\r\n                        if (\r\n                            /^[ \\t]*\\[ *\\]$/.test(text)\r\n                        ) {\r\n                            jsonMap.push([]);\r\n                            _recurse(tree.children[i], jsonMap[jsonMap.length - 1]);\r\n                        } else {\r\n                            let inlineArray;\r\n                            try {\r\n                                inlineArray = JSON.parse(text);\r\n                            } catch (error) {\r\n                                let errorLine =\r\n                                    (damonTree.headless * -1)\r\n                                    + damonTree.damonOriginalLinesMapping.indexOf(treeItemIndex - 1)\r\n                                    + 2;\r\n                                let err = new Error(\r\n                                    \"Error line number \" + errorLine + \": invalid inline lists\"\r\n                                );\r\n                                err.line = errorLine;\r\n                                err.language = \"JSON\";\r\n                                err.type = \"list\";\r\n                                throw err;\r\n                            }\r\n                            let arrayOfPrimitives =\r\n                                    inlineArray.every(function (item) {\r\n                                        if (item === true) {\r\n                                            return true;\r\n                                        } else if (item === false) {\r\n                                            return true;\r\n                                        } else if (item === null) {\r\n                                            return true;\r\n                                        } else if (typeof item == 'string') {\r\n                                            return true;\r\n                                        } else if (\r\n                                            isFinite(item)\r\n                                            && !isNaN(parseFloat(item))\r\n                                            && Number.isFinite(item * 1)\r\n                    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/NaN\r\n                                            && !Number.isNaN(item * 1)\r\n                                        ) { // Number\r\n                                            return true;\r\n                                        } else {\r\n                                            return false;\r\n                                        }\r\n                                    });\r\n                            if (arrayOfPrimitives) {\r\n                                jsonMap.push(inlineArray);\r\n                                // Storing formatting for auto-formatting options\r\n                                if (jsonMap.damonInlineArrays === undefined) {\r\n                                    jsonMap.damonInlineArrays = [];\r\n                                }\r\n                                jsonMap.damonInlineArrays.push(i);\r\n                            } else {\r\n                                let errorLine =\r\n                                    (damonTree.headless * -1)\r\n                                    + damonTree.damonOriginalLinesMapping.indexOf(treeItemIndex - 1)\r\n                                    + 2;\r\n                                let error = new Error(\r\n                                    \"Error line number \" + errorLine + \": no nesting in inline lists\"\r\n                                );\r\n                                error.line = errorLine;\r\n                                error.language = \"DAMON\";\r\n                                throw error;\r\n                            }\r\n                            if (tree.children[i].children.length > 0) {\r\n                                let errorLine =\r\n                                    (damonTree.headless * -1)\r\n                                    + damonTree.damonOriginalLinesMapping.indexOf(treeItemIndex - 1)\r\n                                    + 3;\r\n                                let error = new Error(\r\n                                    \"Error line number \" + errorLine + \": inline lists can't have children\"\r\n                                );\r\n                                error.line = errorLine;\r\n                                error.language = \"DAMON\";\r\n                                throw error;\r\n                            }\r\n                        }\r\n                    } else if (/^[ \\t]*\\{\\}$/.test(text)) {\r\n                        jsonMap.push(new Map());\r\n                        _recurse(tree.children[i], jsonMap[jsonMap.length - 1]);\r\n                    } else if (/^[ \\t]*true$/.test(text)) {\r\n                        jsonMap.push(true);\r\n                    } else if (/^[ \\t]*false$/.test(text)) {\r\n                        jsonMap.push(false);\r\n                    } else if (/^[ \\t]*null$/.test(text)) {\r\n                        jsonMap.push(null);\r\n                    } else if (/^[ \\t]*\".*\"$/.test(text)) {\r\n                        try {\r\n                            jsonMap.push(JSON.parse(`[${text.trimStart()}]`)[0]);\r\n                        } catch (error) {\r\n                            let errorLine =\r\n                                (damonTree.headless * -1)\r\n                                + damonTree.damonOriginalLinesMapping.indexOf(treeItemIndex - 1)\r\n                                + 2;\r\n                            console.error(\r\n                                \"Error line number \" + errorLine + \": not JSON-compliant, detailed error follows\"\r\n                            );\r\n                            error.line = errorLine;\r\n                            error.language = \"JSON\";\r\n                            error.type = \"string\";\r\n                            throw error;\r\n                        }\r\n                    } else if (\r\n                        isFinite(text)\r\n                        && !isNaN(parseFloat(text))\r\n                        && Number.isFinite(text * 1)\r\n                    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/NaN\r\n                        && !Number.isNaN(text * 1)\r\n                    ) {\r\n                        if (\r\n                            text.indexOf(0) == 0\r\n                            && text.length > 1\r\n                            && text.indexOf('.') !== 1\r\n                        ) {\r\n                            let errorLine =\r\n                                (damonTree.headless * -1)\r\n                                + damonTree.damonOriginalLinesMapping.indexOf(treeItemIndex - 1)\r\n                                + 2;\r\n                            let error = new Error(\"Error line number \" + errorLine + \": leading 0\");\r\n                            error.line = errorLine;\r\n                            error.language = \"DAMON\";\r\n                            throw error;\r\n                        }\r\n                        try {\r\n                            jsonMap.push(JSON.parse(`[${text * 1}]`)[0]);\r\n                        } catch (error) {\r\n                            let errorLine =\r\n                                (damonTree.headless * -1)\r\n                                + damonTree.damonOriginalLinesMapping.indexOf(treeItemIndex - 1)\r\n                                + 2;\r\n                            console.error(\r\n                                \"Error line number \" + errorLine + \": not JSON-compliant, detailed error follows\"\r\n                            );\r\n                            error.line = errorLine;\r\n                            error.language = \"JSON\";\r\n                            error.type = \"number\";\r\n                            throw error;\r\n                        }\r\n                    } else if (text * 1 === Infinity) {\r\n                        // Make JSON.parse throw at Infinity\r\n                        try {\r\n                            JSON.parse(text * 1);\r\n                        } catch (error) {\r\n                            let errorLine =\r\n                                (damonTree.headless * -1)\r\n                                + damonTree.damonOriginalLinesMapping.indexOf(treeItemIndex - 1)\r\n                                + 2;\r\n                            console.error(\r\n                                \"Error line number \" + errorLine + \": not JSON-compliant, detailed error follows\"\r\n                            );\r\n                            error.line = errorLine;\r\n                            error.language = \"JSON\";\r\n                            error.type = \"infinity\";\r\n                            throw error;\r\n                        }\r\n                    } else {\r\n                        let errorLine =\r\n                            (damonTree.headless * -1)\r\n                            + damonTree.damonOriginalLinesMapping.indexOf(treeItemIndex - 1)\r\n                            + 2;\r\n                        let error = new Error(\"Error line number \" + errorLine + \": list items can't have a key\");\r\n                        error.line = errorLine;\r\n                        error.language = \"DAMON\";\r\n                        throw error;\r\n                    }\r\n                } else {\r\n                    let errorLine =\r\n                        (damonTree.headless * -1)\r\n                        + damonTree.damonOriginalLinesMapping.indexOf(treeItemIndex - 1)\r\n                        + 2;\r\n                    let error = new Error(\"Error line number \" + errorLine + \": empty list node\");\r\n                    error.line = errorLine;\r\n                    error.language = \"DAMON\";\r\n                    throw error;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param {damonValue} jsonMap\r\n     * @param {boolean} pristine\r\n     * @returns {string}\r\n     */\r\n    mapToDamon(jsonMap, pristine) {\r\n        const $ = this;\r\n        var list = ``;\r\n        if (Array.isArray(jsonMap)) {\r\n            list += '- []\\n';\r\n        } else if (\r\n            typeof jsonMap === 'object'\r\n            && jsonMap !== null\r\n            && jsonMap instanceof Map\r\n            && jsonMap.constructor === Map\r\n        ) {\r\n            list += '- {}\\n';\r\n        } else {\r\n            if (typeof jsonMap == 'string') {\r\n                jsonMap = '\"' + jsonMap + '\"';\r\n            }\r\n            JSON.parse(jsonMap);\r\n            return jsonMap;\r\n        }\r\n        _recurse(jsonMap);\r\n        // Parsing-check\r\n        $.damonToMap(list.slice(0, -1));\r\n        return list.slice(0, -1); // last linefeed\r\n        /**\r\n         * @param {Map<string, any>|Array<any>} jsonMap\r\n         * @param {number} [level=1]\r\n         * @returns {string}\r\n         */\r\n        function _recurse(jsonMap, level = 1) {\r\n            if (\r\n                typeof jsonMap === 'object'\r\n                && jsonMap !== null\r\n                && !Array.isArray(jsonMap)\r\n                && jsonMap instanceof Map\r\n                && jsonMap.constructor === Map\r\n            ) {\r\n                let mapKeys = Array.from(jsonMap.keys()),\r\n                    implicitNullsMap = false;\r\n                if (\r\n                    jsonMap.implicitNulls !== undefined\r\n                    && jsonMap.implicitNulls.length === mapKeys.length\r\n                ) {\r\n                    implicitNullsMap = true;\r\n                }\r\n                for (const [key, value] of jsonMap) {\r\n                    if (\r\n                        typeof value === 'object'\r\n                        && value !== null\r\n                    ) {\r\n                        if (Array.isArray(value)) {\r\n                            let nullsCounter = 0,\r\n                                arrayOfPrimitives = value.filter(function (item) {\r\n                                    if (item === true) {\r\n                                        return true;\r\n                                    } else if (item === false) {\r\n                                        return true;\r\n                                    } else if (item === null) {\r\n                                        nullsCounter++;\r\n                                        return true;\r\n                                    } else if (typeof item == 'string') {\r\n                                        return true;\r\n                                    } else if (\r\n                                        isFinite(item)\r\n                                        && !isNaN(parseFloat(item))\r\n                                        && Number.isFinite(item * 1)\r\n                        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/NaN\r\n                                        && !Number.isNaN(item * 1)\r\n                                    ) { // Number\r\n                                        return true;\r\n                                    } else {\r\n                                        return false;\r\n                                    }\r\n                                });\r\n                            if (\r\n                                ( // No nesting, fits on an archivable line\r\n                                    value.length == arrayOfPrimitives.length\r\n                                    && (level * 4 + 2 + value.join(', ').length + (nullsCounter * 4)) <= 80\r\n                                ) || ( // Inlining specified from parsing\r\n                                    pristine\r\n                                    && jsonMap.damonInlineArrays !== undefined\r\n                                    && jsonMap.damonInlineArrays.indexOf(key) > -1\r\n                                )\r\n                            ) {\r\n                                let line =\r\n                                    '['\r\n                                    + value.map(function (x) {\r\n                                        if (typeof x == 'string') {\r\n                                            x = JSON.stringify(x);\r\n                                        }\r\n                                        return x;\r\n                                    }).join(', ')\r\n                                    + ']';\r\n                                list +=\r\n                                    '    '.repeat(level)\r\n                                    + '- ' + JSON.stringify(key).slice(1, -1) + ': ' + line + '\\n';\r\n                            } else {\r\n                                list += '    '.repeat(level) + '- ' + JSON.stringify(key).slice(1, -1) + ': []\\n';\r\n                                _recurse(value, level + 1);\r\n                            }\r\n                        } else {\r\n                            list += '    '.repeat(level) + '- ' + JSON.stringify(key).slice(1, -1) + ': {}\\n';\r\n                            _recurse(value, level + 1);\r\n                        }\r\n                    } else {\r\n                        if (implicitNullsMap) {\r\n                            list += '    '.repeat(level) + '- ' + JSON.stringify(key).slice(1, -1) + \"\\n\";\r\n                        } else {\r\n                            list += '    '.repeat(level) + '- ' + JSON.stringify(key).slice(1, -1) + ': ';\r\n                            if (value === true) {\r\n                                list += \"true\\n\";\r\n                            } else if (value === false) {\r\n                                list += \"false\\n\";\r\n                            } else if (value === null) {\r\n                                list += \"null\\n\";\r\n                            } else if (\r\n                                Number.isFinite(value)\r\n                                && !Number.isNaN(value)\r\n                            ) {\r\n                                list += value + \"\\n\";\r\n                            } else {\r\n                                list += JSON.stringify(value) + '\\n';\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            } else if (Array.isArray(jsonMap)) {\r\n                for (var i = 0, c = jsonMap.length; i < c; i++) {\r\n                    if (\r\n                        typeof jsonMap[i] === 'object'\r\n                        && jsonMap[i] !== null\r\n                    ) {\r\n                        if (Array.isArray(jsonMap[i])) {\r\n                            let nullsCounter = 0,\r\n                                arrayOfPrimitives = jsonMap[i].filter(function (item) {\r\n                                if (item === true) {\r\n                                    return true;\r\n                                } else if (item === false) {\r\n                                    return true;\r\n                                } else if (item === null) {\r\n                                    nullsCounter++;\r\n                                    return true;\r\n                                } else if (typeof item == 'string') {\r\n                                    return true;\r\n                                } else if (\r\n                                    isFinite(item)\r\n                                    && !isNaN(parseFloat(item))\r\n                                    && Number.isFinite(item * 1)\r\n                        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/NaN\r\n                                    && !Number.isNaN(item * 1)\r\n                                ) { // Number\r\n                                    return true;\r\n                                } else {\r\n                                    return false;\r\n                                }\r\n                            });\r\n                            if ((\r\n                                    jsonMap[i].length == arrayOfPrimitives.length\r\n                                    && (level * 4 + 2 + jsonMap[i].join(', ').length + (nullsCounter * 4)) <= 80\r\n                                ) || (\r\n                                    pristine\r\n                                    && jsonMap.damonInlineArrays !== undefined\r\n                                    && jsonMap.damonInlineArrays.indexOf(i) > -1\r\n                                )\r\n                            ) {\r\n                                let line =\r\n                                    '['\r\n                                    + jsonMap[i].map(function (x) {\r\n                                        if (typeof x == 'string') {\r\n                                            x = JSON.stringify(x);\r\n                                        }\r\n                                        return x;\r\n                                    }).join(', ')\r\n                                    + ']';\r\n                                list += '    '.repeat(level) + '- ' + line + '\\n';\r\n                            } else {\r\n                                list += '    '.repeat(level) + \"- []\\n\";\r\n                                _recurse(jsonMap[i], level + 1);\r\n                            }\r\n                        } else {\r\n                            list += '    '.repeat(level) + \"- {}\\n\";\r\n                            _recurse(jsonMap[i], level + 1);\r\n                        }\r\n                    } else {\r\n                        if (jsonMap[i] === true) {\r\n                            list += '    '.repeat(level) + \"- true\\n\";\r\n                        } else if (jsonMap[i] === false) {\r\n                            list += '    '.repeat(level) + \"- false\\n\";\r\n                        } else if (jsonMap[i] === null) {\r\n                            list += '    '.repeat(level) + \"- null\\n\";\r\n                        } else if (\r\n                            Number.isFinite(jsonMap[i])\r\n                            && !Number.isNaN(jsonMap[i])\r\n                        ) {\r\n                            list += '    '.repeat(level) + '- ' + jsonMap[i] + \"\\n\";\r\n                        } else {\r\n                            list += '    '.repeat(level) + '- ' + JSON.stringify(jsonMap[i]) + '\\n';\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param {damonValue} jsonMap\r\n     * @returns {string}\r\n     */\r\n    mapToJSON(jsonMap) {\r\n        const $ = this;\r\n        var list = ``;\r\n        if (Array.isArray(jsonMap)) {\r\n            list += \"[\\r\\n\";\r\n            _recurse(jsonMap);\r\n            list += \"]\";\r\n            JSON.parse(list);\r\n            return list;\r\n        } else if (\r\n            typeof jsonMap === 'object'\r\n            && jsonMap !== null\r\n            && jsonMap instanceof Map\r\n            && jsonMap.constructor === Map\r\n        ) {\r\n            list += \"{\\r\\n\";\r\n            _recurse(jsonMap);\r\n            list += \"}\";\r\n            JSON.parse(list);\r\n            return list;\r\n        } else {\r\n            if (typeof jsonMap == 'string') {\r\n                jsonMap = JSON.stringify(jsonMap);\r\n            }\r\n            JSON.parse(jsonMap);\r\n            return jsonMap;\r\n        }\r\n        /**\r\n         * @param {Map<string, any>|Array<any>} jsonMap\r\n         * @param {number} [level=1]\r\n         * @returns {string}\r\n         */\r\n        function _recurse(jsonMap, level = 1) {\r\n            if (\r\n                typeof jsonMap === 'object'\r\n                && jsonMap !== null\r\n                && !Array.isArray(jsonMap)\r\n                && jsonMap instanceof Map\r\n                && jsonMap.constructor === Map\r\n            ) {\r\n                for (const [key, value] of jsonMap) {\r\n                    if (\r\n                        typeof value === 'object'\r\n                        && value !== null\r\n                    ) {\r\n                        if (Array.isArray(value)) {\r\n                            if (value.length > 0) {\r\n                                list += '    '.repeat(level) + `${JSON.stringify(key)}: [\\r\\n`;\r\n                                _recurse(value, level + 1);\r\n                                list += '    '.repeat(level) + `]`;\r\n                            } else {\r\n                                list += '    '.repeat(level) + `${JSON.stringify(key)}: []`;\r\n                            }\r\n                        } else {\r\n                            if (Array.from(value.keys()).length > 0) {\r\n                                list += '    '.repeat(level) + `${JSON.stringify(key)}: {\\r\\n`;\r\n                                _recurse(value, level + 1);\r\n                                list += '    '.repeat(level) + `}`;\r\n                            } else {\r\n                                list += '    '.repeat(level) + `${JSON.stringify(key)}: {}`;\r\n                            }\r\n                        }\r\n                    } else {\r\n                        if (value === true) {\r\n                            list += '    '.repeat(level) + `${JSON.stringify(key)}` + ': ' + \"true\";\r\n                        } else if (value === false) {\r\n                            list += '    '.repeat(level) + `${JSON.stringify(key)}` + ': ' + \"false\";\r\n                        } else if (value === null) {\r\n                            list += '    '.repeat(level) + `${JSON.stringify(key)}` + ': ' + \"null\";\r\n                        } else if (\r\n                            Number.isFinite(value)\r\n                            && !Number.isNaN(value)\r\n                        ) {\r\n                            list += '    '.repeat(level) + `${JSON.stringify(key)}` + ': ' + value;\r\n                        } else {\r\n                            list += '    '.repeat(level) + `${JSON.stringify(key)}` + ': ' + JSON.stringify(value);\r\n                        }\r\n                    }\r\n                    if (key != Array.from(jsonMap.keys())[Array.from(jsonMap.keys()).length - 1]) {\r\n                        list += \",\\r\\n\";\r\n                    } else {\r\n                        list += \"\\r\\n\";\r\n                    }\r\n                }\r\n            } else if (Array.isArray(jsonMap)) {\r\n                for (var i = 0, c = jsonMap.length; i < c; i++) {\r\n                    if (\r\n                        typeof jsonMap[i] === 'object'\r\n                        && jsonMap[i] !== null\r\n                    ) {\r\n                        if (Array.isArray(jsonMap[i])) {\r\n                            if (jsonMap[i].length > 0) {\r\n                                list += '    '.repeat(level) + `[\\r\\n`;\r\n                                _recurse(jsonMap[i], level + 1);\r\n                                list += '    '.repeat(level) + `]`;\r\n                            } else {\r\n                                list += '    '.repeat(level) + `[]`;\r\n                            }\r\n                        } else {\r\n                            if (Array.from(jsonMap[i].keys()).length > 0) {\r\n                                list += '    '.repeat(level) + `{\\r\\n`;\r\n                                _recurse(jsonMap[i], level + 1);\r\n                                list += '    '.repeat(level) + `}`;\r\n                            } else {\r\n                                list += '    '.repeat(level) + `{}`;\r\n                            }\r\n                        }\r\n                    } else {\r\n                        if (jsonMap[i] === true) {\r\n                            list += '    '.repeat(level) + \"true\";\r\n                        } else if (jsonMap[i] === false) {\r\n                            list += '    '.repeat(level) + \"false\";\r\n                        } else if (jsonMap[i] === null) {\r\n                            list += '    '.repeat(level) + \"null\";\r\n                        } else if (\r\n                            Number.isFinite(jsonMap[i])\r\n                            && !Number.isNaN(jsonMap[i])\r\n                        ) {\r\n                            list += '    '.repeat(level) + jsonMap[i];\r\n                        } else {\r\n                            list += '    '.repeat(level) + JSON.stringify(jsonMap[i]);\r\n                        }\r\n                    }\r\n                    if (i != c - 1) {\r\n                        list += \",\\r\\n\";\r\n                    } else {\r\n                        list += \"\\r\\n\";\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param {string} damonString\r\n     * @returns {Array<Array<string|number>>} pathsList\r\n     */\r\n    getPathsList(damonString) {\r\n        const $ = this;\r\n        let damonMap = $.damonToMap(damonString),\r\n            pathsList = [];\r\n        _walkAndPushPaths(damonMap);\r\n        return pathsList;\r\n\r\n        /**\r\n         * @param {Map<string, any>|Array<any>} map\r\n         * @param {Array<string|number>} targetPath\r\n         * @param {Array<string|number>} [currentPath=[]]\r\n        */\r\n        function _walkAndPushPaths(map, currentPath = []) {\r\n            if (\r\n                typeof map === 'object'\r\n                && map !== null\r\n                && !Array.isArray(map)\r\n                && map instanceof Map\r\n                && map.constructor === Map\r\n            ) {\r\n                for (const [key, value] of map) {\r\n                    if (\r\n                        typeof value === 'object'\r\n                        && value !== null\r\n                        && !Array.isArray(value)\r\n                        && value instanceof Map\r\n                        && value.constructor === Map\r\n                        && Array.from(value.keys()).length\r\n                    ) {\r\n                        pathsList.push(currentPath.concat(key));\r\n                        _walkAndPushPaths(value, currentPath.concat([key]));\r\n                    } else if (\r\n                        Array.isArray(value)\r\n                        && (\r\n                            map.damonInlineArrays == undefined\r\n                            || map.damonInlineArrays.indexOf(key) === -1\r\n                        ) && value.length\r\n                    ) {\r\n                        pathsList.push(currentPath.concat(key));\r\n                        _walkAndPushPaths(value, currentPath.concat([key]));\r\n                    } else {\r\n                        pathsList.push(currentPath.concat(key).concat(value));\r\n                    }\r\n                }\r\n            } else {\r\n                for (let i = 0, c = map.length; i < c; i++) {\r\n                    if (\r\n                        typeof map[i] === 'object'\r\n                        && map[i] !== null\r\n                        && !Array.isArray(map[i])\r\n                        && map[i] instanceof Map\r\n                        && map[i].constructor === Map\r\n                        && Array.from(map[i].keys()).length\r\n                    ) {\r\n                        pathsList.push(currentPath.concat(i));\r\n                        _walkAndPushPaths(map[i], currentPath.concat([i]));\r\n                    } else if (\r\n                        Array.isArray(map[i])\r\n                        && (\r\n                            map.damonInlineArrays == undefined\r\n                            || map.damonInlineArrays.indexOf(i) === -1\r\n                        ) && map[i].length\r\n                    ) {\r\n                        pathsList.push(currentPath.concat(i));\r\n                        _walkAndPushPaths(map[i], currentPath.concat([i]));\r\n                    } else {\r\n                        pathsList.push(currentPath.concat(map[i]));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param {string} damon\r\n     * @param {Array<string|number>} path\r\n     * @returns {Array<Array<number>>}\r\n     */\r\n    getRangeFromPath(damon, path) {\r\n        const $ = this;\r\n        let damonMap = $.damonToMap(damon),\r\n            mapIndex = -1,\r\n            found = false;\r\n        _incrementMapIndexUntilReaching(damonMap, path);\r\n        let totalLines = $.mapIndexToLine(damonMap, mapIndex);\r\n        let lineText = $._getLines(damon)[totalLines],\r\n            start = 0,\r\n            end = lineText.length;\r\n        if (path.length == 1) {\r\n            if (typeof path[path.length - 1] == 'string') {\r\n                start =\r\n                    lineText.length\r\n                    - lineText.trimStart().slice(2 + path[path.length - 1].length + 2).trimStart().length;\r\n            } else {\r\n                start = lineText.length - lineText.trimStart().slice(2).length;\r\n            }\r\n        } else {\r\n            if (typeof path[path.length - 2] == 'string') {\r\n                if (typeof path[path.length - 1] == 'string') {\r\n                    start =\r\n                        lineText.length\r\n                        - lineText.trimStart().slice(2 + path[path.length - 1].length + 2).trimStart().length;\r\n                } else {\r\n                    if (\r\n                        lineText[lineText.length - 1] == ']'\r\n                        && !/\\[ *\\]$/.test(lineText)\r\n                    ) {\r\n                        let arrayText = lineText.trimStart().slice(2 + path[path.length - 2].length + 2),\r\n                            array = JSON.parse(arrayText),\r\n                            occurences =\r\n                                array.slice(0, path[path.length - 1].length)\r\n                                    .reduce((acc, value) => acc + (value === array[path[path.length - 1]]), 0),\r\n                            index = 0,\r\n                            match = array[path[path.length - 1]];\r\n                        if (typeof match == 'string')\r\n                            match = '\"' + match + '\"';\r\n                        for (let i = 0, c = occurences + 1; i < c; i++) {\r\n                            index = arrayText.indexOf(match, index);\r\n                        }\r\n                        start = lineText.length - arrayText.length + index;\r\n                        end = start + match.length;\r\n                    } else {\r\n                        start = lineText.length - lineText.trimStart().slice(2).length;\r\n                    }\r\n                }\r\n            } else {\r\n                if (typeof path[path.length - 1] == 'string') {\r\n                    start =\r\n                        lineText.length\r\n                        - lineText.trimStart().slice(2 + path[path.length - 1].length + 2).trimStart().length;\r\n                } else {\r\n                    if (\r\n                        lineText[lineText.length - 1] == ']'\r\n                        && !/\\[ *\\]$/.test(lineText)\r\n                    ) {\r\n                        let arrayText = lineText.trimStart().slice(2),\r\n                            array = JSON.parse(arrayText),\r\n                            occurences =\r\n                                array.slice(0, path[path.length - 1])\r\n                                    .reduce((acc, value) => acc + (value === array[path[path.length - 1]]), 0),\r\n                            index = 0,\r\n                            match = array[path[path.length - 1]];\r\n                        if (typeof match == 'string')\r\n                            match = '\"' + match + '\"';\r\n                        for (let i = 0, c = occurences + 1; i < c; i++) {\r\n                            index = arrayText.indexOf(match, index);\r\n                        }\r\n                        start = lineText.length - arrayText.length + index;\r\n                        end = start + match.length;\r\n                    } else {\r\n                        start = lineText.length - lineText.trimStart().slice(2).length;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return [[totalLines, start], [totalLines, end]];\r\n        /**\r\n         * @param {Map<string, any>|Array<any>} map\r\n         * @param {Array<string|number>} targetPath\r\n         * @param {Array<string|number>} [currentPath=[]]\r\n        */\r\n        function _incrementMapIndexUntilReaching(map, targetPath, currentPath = []) {\r\n            mapIndex += 1;\r\n            if (\r\n                typeof map === 'object'\r\n                && map !== null\r\n                && !Array.isArray(map)\r\n                && map instanceof Map\r\n                && map.constructor === Map\r\n            ) {\r\n                for (const [key, value] of map) {\r\n                    if (found == true) {\r\n                        return;\r\n                    }\r\n                    mapIndex += 1;\r\n                    if (JSON.stringify(targetPath) === JSON.stringify(currentPath.concat([key]))) {\r\n                        found = true;\r\n                        return;\r\n                    }\r\n                    if (\r\n                        typeof value === 'object'\r\n                        && value !== null\r\n                        && !Array.isArray(value)\r\n                        && value instanceof Map\r\n                        && value.constructor === Map\r\n                        && Array.from(value.keys()).length\r\n                    ) {\r\n                        mapIndex -= 1;\r\n                        _incrementMapIndexUntilReaching(value, targetPath, currentPath.concat([key]));\r\n                    } else if (Array.isArray(value) && value.length) {\r\n                        if (\r\n                            map.damonInlineArrays == undefined\r\n                            || map.damonInlineArrays.indexOf(key) === -1\r\n                        ) {\r\n                            mapIndex -= 1;\r\n                            _incrementMapIndexUntilReaching(value, targetPath, currentPath.concat([key]));\r\n                        } else if (\r\n                            JSON.stringify(targetPath.slice(0, -1)) === JSON.stringify(currentPath.concat([key]))\r\n                        ) {\r\n                            found = true;\r\n                            return;\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                for (let i = 0, c = map.length; i < c; i++) {\r\n                    if (found == true) {\r\n                        return;\r\n                    }\r\n                    mapIndex += 1;\r\n                    if (JSON.stringify(targetPath) === JSON.stringify(currentPath.concat([i]))) {\r\n                        found = true;\r\n                        return;\r\n                    }\r\n                    if (\r\n                        typeof map[i] === 'object'\r\n                        && map[i] !== null\r\n                        && !Array.isArray(map[i])\r\n                        && map[i] instanceof Map\r\n                        && map[i].constructor === Map\r\n                        && Array.from(map[i].keys()).length\r\n                    ) {\r\n                        mapIndex -= 1;\r\n                        _incrementMapIndexUntilReaching(map[i], targetPath, currentPath.concat([i]));\r\n                    } else if (Array.isArray(map[i]) && map[i].length) {\r\n                        if (\r\n                            map.damonInlineArrays == undefined\r\n                            || map.damonInlineArrays.indexOf(i) === -1\r\n                        ) {\r\n                            mapIndex -= 1;\r\n                            _incrementMapIndexUntilReaching(map[i], targetPath, currentPath.concat([i]));\r\n                        } else if (\r\n                            JSON.stringify(targetPath.slice(0, -1)) === JSON.stringify(currentPath.concat([i]))\r\n                        ) {\r\n                            found = true;\r\n                            return;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {string} damon\r\n     * @param {Array<number} coordinates\r\n     * @returns {Array<Array<number>>}\r\n     */\r\n    getTokenFromCoordinates(damon, coordinates) {\r\n        const $ = this;\r\n        let token = {};\r\n        let damonLines = $._getLines(damon).slice(0, coordinates[0]);\r\n        if (damonLines[coordinates[0] -  1] == '') {\r\n            token.type = 'newline';\r\n            token.path = null;\r\n            token.range = [coordinates, coordinates];\r\n            return token;\r\n        }\r\n        if (/^[ \\t]+$/.test(damonLines[coordinates[0] -  1])) {\r\n            token.type = 'indentation';\r\n            token.path = null;\r\n            token.range = [[coordinates[0], 1], [coordinates[0], damonLines[damonLines.length - 1].length]];\r\n            return token;\r\n        }\r\n        if (/^[ \\t]+/.test(damonLines[coordinates[0] -  1].slice(0, coordinates[1] - 1))) {\r\n            token.type = 'indentation';\r\n            token.range = [\r\n                [coordinates[0], 1],\r\n                [coordinates[0], damonLines[coordinates[0] -  1].match(/^[ \\t]+/)[0].length]\r\n            ];\r\n        }\r\n        if (/^ *\\/\\//.test(damonLines[coordinates[0] -  1])) {\r\n            if (token.type == 'indentation') {\r\n                token.path = null;\r\n                return token;\r\n            }\r\n            token.type = 'comment';\r\n            token.path = null;\r\n            token.range = [\r\n                [[coordinates[0], damonLines[coordinates[0] -  1].split('//')[0].length]],\r\n                [[coordinates[0], damonLines[coordinates[0] -  1].length]]\r\n            ];\r\n            return token;\r\n        }\r\n\r\n        if (damonLines.length == 1) {\r\n            try {\r\n                let jsonValue = JSON.parse(damon);\r\n                if (\r\n                    jsonValue === true\r\n                    || jsonValue === false\r\n                    || jsonValue === null\r\n                    || typeof jsonValue === 'string'\r\n                    || typeof jsonValue === 'number'\r\n                ) {\r\n                    let leftPadding = damon.match(/^ */)[0].length,\r\n                        rightPadding = damon.match(/ *$/)[0].length;\r\n                    token.type = 'null';\r\n                    if (typeof jsonValue !== 'object')\r\n                        token.type = typeof jsonValue;\r\n                    token.path = null;\r\n                    token.range = [[0, leftPadding], [0, damon.length - rightPadding]];\r\n                    return token;\r\n                }\r\n            } catch (error) {\r\n                // Continue\r\n            }\r\n        }\r\n        let damonMap = $.damonToMap(damonLines.join('\\n')),\r\n            currentLevelKeys = Array.from(damonMap.keys()),\r\n            path = [];\r\n        while (currentLevelKeys.length) {\r\n            let key = currentLevelKeys[currentLevelKeys.length - 1];\r\n            path.push(key);\r\n            if (\r\n                typeof damonMap === 'object'\r\n                && damonMap !== null\r\n                && !Array.isArray(damonMap)\r\n                && damonMap instanceof Map\r\n                && damonMap.constructor === Map\r\n            ) {\r\n                damonMap = damonMap.get(key);\r\n            } else if (Array.isArray(damonMap)) {\r\n                damonMap = damonMap[key]\r\n            }\r\n            if (\r\n                damonMap === true\r\n                || damonMap === false\r\n                || damonMap === null\r\n                || typeof damonMap === 'string'\r\n                || typeof damonMap === 'number'\r\n            ) {\r\n                break;\r\n            }\r\n            currentLevelKeys = Array.from(damonMap.keys());\r\n        }\r\n        token.path = path;\r\n        let valueRange = $.getRangeFromPath(damon, path);\r\n        if (typeof path[path.length - 1] == 'string') {\r\n            if (coordinates[1] < valueRange[0][1]) {\r\n                let propertyEndRange =\r\n                damonLines[coordinates[0] - 1].slice(0, (-1 * (valueRange[1][1] - valueRange[0][1])) - 1).length;\r\n                if (coordinates[1]  < propertyEndRange) {\r\n                    // find property start range\r\n                    let propertyStartRange = damonLines[coordinates[0] -  1].match(/^[ \\t]+/)[0].length + 3;\r\n                    if (coordinates[1] >= propertyStartRange) {\r\n                        token.type = 'property';\r\n                        token.range = [[coordinates[0], propertyStartRange], [coordinates[0], propertyEndRange]];\r\n                    } else {\r\n                        token.type = 'hyphen';\r\n                        token.range = [\r\n                            [coordinates[0], propertyStartRange - 2],\r\n                            [coordinates[0], propertyStartRange - 1]\r\n                        ];\r\n                    }\r\n                } else {\r\n                    token.type = 'separator';\r\n                    token.range = [[coordinates[0], propertyEndRange + 1], [coordinates[0], valueRange[0][1] - 1]];\r\n                }\r\n            } else {\r\n                // inline array or damonValue\r\n                token.type = '?';\r\n                token.range = valueRange;\r\n            }\r\n        } else {\r\n            if (coordinates[1] < valueRange[0][1]) {\r\n                token.type = 'hyphen';\r\n                let hyphenStartRange = damonLines[coordinates[0] -  1].match(/^[ \\t]+/)[0].length + 1;\r\n                token.range = [\r\n                    [coordinates[0], hyphenStartRange],\r\n                    [coordinates[0], hyphenStartRange + 1]\r\n                ];\r\n            } else {\r\n                token.type = '?';\r\n                token.range = valueRange;\r\n            }\r\n        }\r\n        return token;\r\n    }\r\n\r\n    /**\r\n     * @param {damonValue} map\r\n     * @param {number} mapIndex\r\n     * @returns number\r\n     */\r\n        mapIndexToLine(map, mapIndex) {\r\n        let totalLines = 0,\r\n            match = 0;\r\n        if (map.headless)\r\n            mapIndex -= 1;\r\n        for (let i = 0, c = map.damonOriginalLinesMapping.length; i < c; i++) {\r\n            if (map.damonOriginalLinesMapping[i] !== null) {\r\n                match++;\r\n            }\r\n            if (match == mapIndex) {\r\n                totalLines = i + 1;\r\n                break;\r\n            }\r\n        }\r\n        return totalLines;\r\n    }\r\n};\r\n", "(function () {\r\n    window.Damon = require('./Damon.js');\r\n})();\r\n"],
  "mappings": "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",
  "names": ["v", "d", "b", "__assign", "o", "clarinet", "err", "i", "error", "jsonMap"]
}
